
      <div style={{ fontSize: 13, color: "#6b7280", marginBottom: 12 }}>
        アクセス中の賞品ID：<code>{prizeId}</code>
      </div>

      {loadingPrize ? (
        <div>読み込み中…</div>
      ) : error ? (
        <div style={{ color: "crimson" }}>{error}</div>
      ) : !prize ? (
        <div>データがありません。</div>
      ) : (
        <>
          <div
            style={{
              padding: 14,
              border: "1px solid #e5e7eb",
              borderRadius: 12,
              background: "#f9fafb",
              marginBottom: 14,
            }}
          >
            <div style={{ fontWeight: 700, marginBottom: 6 }}>{prize.prizeName}</div>
            <div style={{ fontSize: 13, color: "#374151" }}>
              公開予定（JST）：{prize.resultTimeJST || "未設定"}
            </div>
          </div>

          {!isPublished ? (
            <div
              style={{
                padding: 16,
                border: "1px solid #f59e0b",
                borderRadius: 12,
                background: "#fffbeb",
              }}
            >
              <div style={{ fontWeight: 700, marginBottom: 6 }}>
                まだ結果は公開されていません ⏳
              </div>
              <div>公開まで：{remainSec != null ? fmtHMS(remainSec) : "—"}</div>
            </div>
          ) : (
            <form
              onSubmit={onSubmit}
              style={{ display: "grid", gap: 10, marginTop: 4 }}
            >
              <div>
                <label style={{ display: "block", fontSize: 12, color: "#555" }}>
                  抽選番号
                </label>
                <input
                  value={entryNumber}
                  onChange={(e) => setEntryNumber(e.target.value)}
                  placeholder="例：001"
                  style={{
                    padding: 10,
                    borderRadius: 8,
                    border: "1px solid #d1d5db",
                    width: "100%",
                  }}
                />
              </div>

              <div>
                <label style={{ display: "block", fontSize: 12, color: "#555" }}>
                  パスワード
                </label>
                <input
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  placeholder="例：1234"
                  style={{
                    padding: 10,
                    borderRadius: 8,
                    border: "1px solid #d1d5db",
                    width: "100%",
                  }}
                />
              </div>

              <button
                type="submit"
                disabled={sending}
                style={{
                  padding: "10px 14px",
                  borderRadius: 8,
                  border: "1px solid #2563eb",
                  background: "#2563eb",
                  color: "white",
                  cursor: "pointer",
                  fontWeight: 600,
                }}
              >
                {sending ? "送信中…" : "結果を確認"}
              </button>

              {resultMsg && (
                <div
                  style={{
                    marginTop: 6,
                    padding: 12,
                    border: "1px solid #e5e7eb",
                    borderRadius: 8,
                    background: "#fff",
                  }}
                >
                  {resultMsg}
                </div>
              )}
            </form>
          )}
        </>
      )}
    </div>
  );
}
```

---

# 2) （任意）フロントに API ベースURLを設定したい場合

**新規ファイル作成**：`/Users/m-aoki/Downloads/comiket-lottery-app/frontend/.env` に**丸ごと**次を保存  
（Render など本番ではここを本番URLに切り替え）

```
REACT_APP_API_BASE=http://localhost:3001
```

> `.env` を追加・変更した場合は **`npm start` を一度止めて再起動** してください。

---

# 3) テスト手順

1) バックエンド（3001）
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/backend"
PORT=3001 node index.js
```

2) フロント（3000 か 3002）
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/frontend"
# ポートが被る時は PORT=3002 を付ける
npm start
```

3) ブラウザでアクセス  
- `http://localhost:3000/?prizeId=A001`  
  公開前 → カウントダウン表示  
  公開後 → 入力フォーム表示 → 結果表示（例：`001 / 1234`）

---

# 4) QRコード運用のコツ
- 商品ごとに **`?prizeId=XXXX` を含むURL** をQR化するだけでOK：  
  例）`https://<フロントURL>/?prizeId=A001`
- 公開前は勝手にカウントダウン、公開後にだけフォーム解放されます。

---

必要なら、**管理ページ（一覧とQR出力）** も作れます。  
まずは上記の App.jsx を上書き → 動作を確認してみてください！

---

user:
今ポート3000で動いてます

---

system:


---

assistant:
了解しました 👍  
いまフロントエンドが **ポート3000** で正常に動いているんですね。  

---

## 現状の構成まとめ
- **バックエンド (API)** → ポート **3001**  
  - `curl http://localhost:3001/...` で動作確認済み
- **フロントエンド (React)** → ポート **3000**  
  - ブラウザで `http://localhost:3000/?prizeId=A001` などにアクセスできる

---

## 注意点
1. **APIのURL**
   - フロントからバックエンドを叩くときに `http://localhost:3001` を参照します。  
   - `App.jsx` で `API_BASE` を `http://localhost:3001` にしておけばOKです。  
   - `.env` に設定している場合は `npm start` 再起動後に反映されます。

2. **ポート3000と3001の役割**
   - React (3000) はユーザーのブラウザで表示する画面。  
   - Express/Node (3001) は結果照会のAPIサーバ。  
   - 通信は `axios` 経由で `3000 → 3001` に行われます。

3. **本番デプロイ時**
   - 開発環境だと `3000` と `3001` を別々に動かす必要があります。  
   - 本番に載せる場合は `npm run build` でビルドしたフロントを **バックエンド(Express)に統合** して、1つのポートだけで済ませるのが一般的です。

---

## 次にできること
- **今のまま動作確認を続ける**  
  `http://localhost:3000/?prizeId=A001` で、公開前 → カウントダウン、公開後 → 結果照会フォーム、という流れが確認できればOKです。
- **本番用に1ポート化する**  
  → `npm run build` して、バックエンドの `express.static` で配信させる。  

---

👉 今って「まずはローカルで動作確認したい」感じですか？  
それとも「最終的にサーバ1つで運用（3001だけでフロントもバックも動かす）」方向にしたいですか？

---

user:
「まずはローカルで動作確認したい」感じ

---

system:


---

system:


---

assistant:
了解！では「ローカルで動作確認」をサクッと通す手順を、**そのままコピペで実行できる形**でまとめます。  
（フロント=3000、バック=3001 のままでOK）

---

# 1) バックエンド起動（3001）
別ターミナルで実行してください。
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/backend"
PORT=3001 node index.js
# → Lottery backend running on port 3001
```

## （すぐ当落を見たい場合の設定）
公開前ガードで「まだ結果発表前です」が出る場合は、どちらかでテストできます。

### 方法A: 公開時刻を過去にする（推奨）
`/Users/m-aoki/Downloads/comiket-lottery-app/backend/lotteryData.js` の対象賞品の
`resultTimeJST` を現在より**過去**にして保存 → バックエンド再起動。

```js
// 例: A001 を“今日の 09:00 JST”に
resultTimeJST: "2025-08-18 09:00"
```

### 方法B: 一時的に公開扱い（環境変数）
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/backend"
FORCE_PUBLISH_ALL=1 PORT=3001 node index.js
```
> 本番では外してください。

---

# 2) フロントエンド起動（3000）
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/frontend"
npm install
npm start
# → ブラウザで http://localhost:3000 を開く
```

> `App.jsx` は既にフォーム＋公開時刻対応版ならそのままでOKです。  
> API先を環境変数で固定したい場合は `frontend/.env` に  
> `REACT_APP_API_BASE=http://localhost:3001` を追加し、**npm start を再起動**。

---

# 3) 動作確認の流れ

## 3-1. 商品情報の取得（フロントから自動）
ブラウザで以下のURLを開きます。  
**参加者用URL（QR化想定）**：  
`http://localhost:3000/?prizeId=A001`

画面には：
- 賞品名
- 公開予定（JST）
- 公開前ならカウントダウン
- 公開後にフォームが表示（抽選番号＋パスワード）

## 3-2. 当落確認（公開後）
入力例：
- 抽選番号：`001`
- パスワード：`1234`

→ 当選なら  
`🎉 おめでとうございます！「サンプル賞品A」に当選しました！`  
公開前なら  
`まだ結果発表前です。公開時刻をお待ちください。`

---

# 4) APIを直接確認したい場合（任意）

```bash
# 現在時刻（UTC）
curl http://localhost:3001/api/now

# デバッグ（公開時刻の解釈と比較）
curl http://localhost:3001/api/debug/A001

# 結果チェック
curl -X POST http://localhost:3001/api/check \
  -H "Content-Type: application/json" \
  -d '{"prizeId":"A001","entryNumber":"001","password":"1234"}'
```

---

# 5) QRコード用URL（印刷・掲示）
今はローカルなので例として：
```
http://localhost:3000/?prizeId=A001
```
本番デプロイ後はフロントの本番URL＋同じクエリをQR化すればOK。

---

# 6) つまずき対処（要点だけ）
- **フロントが「生HTML」になる**  
  → 3000番が Express に掴まれていないか。`lsof -i :3000` → Nodeをkill → `npm start` やり直し。  
- **公開前のまま**  
  → 3つのどれか：`resultTimeJST` を過去に、`FORCE_PUBLISH_ALL=1`、または `api/debug` で時刻を確認。  
- **通信エラー**  
  → バックが 3001 で起動しているか、フロントの `REACT_APP_API_BASE` が `http://localhost:3001` かを確認。

---

この手順で「QRリンク → 公開前/後の表示 → 本人確認 → 当落表示」までローカルで通せます。  
次は「管理ページ（一覧とQR発行）」か「本番（Render）1ポート運用」に進めますが、どちらから行きますか？

---

user:
うまく動いたので、進みます

---

system:


---

system:


---

assistant:
いいね！このまま**管理画面（QR発行）**まで一気に進めます。  
以下、すべて**明示的な手順**で書きます。必要な箇所は「丸ごと上書き」か「新規作成」かも明記します。

---

## 0) 追加ライブラリのインストール（QR生成）
**コマンドを実行してください：**
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/frontend"
npm install react-qr-code
```

---

## 1) 参加者ページをコンポーネント化
いまの `App.jsx` のロジックを「参加者ページ」に分離します。

### 新規作成：`/Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/Participant.jsx`
**以下を“丸ごとコピペして保存”してください。**
```jsx
import React, { useEffect, useMemo, useState } from "react";
import axios from "axios";

// APIのベースURL（.env で上書き可）
const API_BASE = process.env.REACT_APP_API_BASE || "http://localhost:3001";

// 秒→HH:MM:SS
function fmtHMS(sec) {
  const s = Math.max(0, Math.floor(sec));
  const h = String(Math.floor(s / 3600)).padStart(2, "0");
  const m = String(Math.floor((s % 3600) / 60)).padStart(2, "0");
  const ss = String(Math.floor(s % 60)).padStart(2, "0");
  return `${h}:${m}:${ss}`;
}

/**
 * 参加者用ページ
 * props:
 *   initialPrizeId?: string  // ルーターから渡す場合に使用
 */
export default function Participant({ initialPrizeId }) {
  // 1) URLの ?prizeId= を最優先、無ければ props、さらに無ければ "A001"
  const prizeId = useMemo(() => {
    const p = new URLSearchParams(window.location.search).get("prizeId");
    return p || initialPrizeId || "A001";
  }, [initialPrizeId]);

  const [prize, setPrize] = useState(null);
  const [loadingPrize, setLoadingPrize] = useState(true);
  const [error, setError] = useState("");

  const [entryNumber, setEntryNumber] = useState("");
  const [password, setPassword] = useState("");
  const [resultMsg, setResultMsg] = useState("");
  const [sending, setSending] = useState(false);

  const publishAt = useMemo(() => {
    if (!prize?.publishTimeParsedUTC) return null;
    const d = new Date(prize.publishTimeParsedUTC);
    return isNaN(d) ? null : d;
  }, [prize]);

  const [remainSec, setRemainSec] = useState(null);
  const isPublished = useMemo(() => {
    if (!publishAt) return true;
    return new Date() >= publishAt;
  }, [publishAt]);

  useEffect(() => {
    let timer;
    if (publishAt) {
      const tick = () => {
        const now = new Date();
        setRemainSec((publishAt.getTime() - now.getTime()) / 1000);
      };
      tick();
      timer = setInterval(tick, 1000);
    }
    return () => timer && clearInterval(timer);
  }, [publishAt]);

  // 商品情報取得
  useEffect(() => {
    setLoadingPrize(true);
    setError("");
    axios
      .get(`${API_BASE}/api/product/${encodeURIComponent(prizeId)}`)
      .then((res) => setPrize(res.data))
      .catch(() => setError("商品が見つかりません。QRまたはURLを確認してください。"))
      .finally(() => setLoadingPrize(false));
  }, [prizeId]);

  // 結果確認
  const onSubmit = async (e) => {
    e.preventDefault();
    setResultMsg("");
    if (!entryNumber || !password) {
      setResultMsg("抽選番号とパスワードを入力してください。");
      return;
    }
    try {
      setSending(true);
      const res = await axios.post(`${API_BASE}/api/check`, {
        prizeId,
        entryNumber,
        password,
      });
      setResultMsg(res.data?.result ?? "結果を取得できませんでした。");
    } catch {
      setResultMsg("通信エラーが発生しました。時間を置いてお試しください。");
    } finally {
      setSending(false);
    }
  };

  return (
    <div style={{ padding: 16, maxWidth: 520, margin: "0 auto" }}>
      <h1 style={{ marginBottom: 8 }}>抽選アプリ 🎲</h1>
      <div style={{ fontSize: 13, color: "#6b7280", marginBottom: 12 }}>
        アクセス中の賞品ID：<code>{prizeId}</code>
      </div>

      {loadingPrize ? (
        <div>読み込み中…</div>
      ) : error ? (
        <div style={{ color: "crimson" }}>{error}</div>
      ) : !prize ? (
        <div>データがありません。</div>
      ) : (
        <>
          <div
            style={{
              padding: 14,
              border: "1px solid #e5e7eb",
              borderRadius: 12,
              background: "#f9fafb",
              marginBottom: 14,
            }}
          >
            <div style={{ fontWeight: 700, marginBottom: 6 }}>{prize.prizeName}</div>
            <div style={{ fontSize: 13, color: "#374151" }}>
              公開予定（JST）：{prize.resultTimeJST || "未設定"}
            </div>
          </div>

          {!isPublished ? (
            <div
              style={{
                padding: 16,
                border: "1px solid #f59e0b",
                borderRadius: 12,
                background: "#fffbeb",
              }}
            >
              <div style={{ fontWeight: 700, marginBottom: 6 }}>
                まだ結果は公開されていません ⏳
              </div>
              <div>公開まで：{remainSec != null ? fmtHMS(remainSec) : "—"}</div>
            </div>
          ) : (
            <form onSubmit={onSubmit} style={{ display: "grid", gap: 10, marginTop: 4 }}>
              <div>
                <label style={{ display: "block", fontSize: 12, color: "#555" }}>
                  抽選番号
                </label>
                <input
                  value={entryNumber}
                  onChange={(e) => setEntryNumber(e.target.value)}
                  placeholder="例：001"
                  style={{
                    padding: 10,
                    borderRadius: 8,
                    border: "1px solid #d1d5db",
                    width: "100%",
                  }}
                />
              </div>
              <div>
                <label style={{ display: "block", fontSize: 12, color: "#555" }}>
                  パスワード
                </label>
                <input
                  type="password"
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  placeholder="例：1234"
                  style={{
                    padding: 10,
                    borderRadius: 8,
                    border: "1px solid #d1d5db",
                    width: "100%",
                  }}
                />
              </div>
              <button
                type="submit"
                disabled={sending}
                style={{
                  padding: "10px 14px",
                  borderRadius: 8,
                  border: "1px solid #2563eb",
                  background: "#2563eb",
                  color: "white",
                  cursor: "pointer",
                  fontWeight: 600,
                }}
              >
                {sending ? "送信中…" : "結果を確認"}
              </button>
              {resultMsg && (
                <div
                  style={{
                    marginTop: 6,
                    padding: 12,
                    border: "1px solid #e5e7eb",
                    borderRadius: 8,
                    background: "#fff",
                  }}
                >
                  {resultMsg}
                </div>
              )}
            </form>
          )}
        </>
      )}
    </div>
  );
}
```

---

## 2) 管理画面（QR発行）
- 複数の賞品IDを**カンマ区切り**で入力 → 各賞品のQRを生成  
- QR は **参加者用URL（?prizeId=xxx）** をエンコード  
- `確認` ボタンで `/api/product/:id` を叩いて商品名と公開時刻を表示  
- `URLコピー` と `PNG保存` を用意

### 新規作成：`/Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/Admin.jsx`
**以下を“丸ごとコピペして保存”してください。**
```jsx
import React, { useMemo, useState } from "react";
import QRCode from "react-qr-code";
import axios from "axios";

// フロントのベースURL（QRに埋め込む先）
const FRONT_BASE = process.env.REACT_APP_FRONT_BASE || "http://localhost:3000";
// バックエンド API
const API_BASE = process.env.REACT_APP_API_BASE || "http://localhost:3001";

export default function Admin() {
  const [idsInput, setIdsInput] = useState("A001");
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);

  const prizeIds = useMemo(
    () => idsInput.split(",").map((s) => s.trim()).filter(Boolean),
    [idsInput]
  );

  const buildUrl = (id) => `${FRONT_BASE}/?prizeId=${encodeURIComponent(id)}`;

  const loadInfo = async () => {
    setLoading(true);
    const result = [];
    for (const id of prizeIds) {
      try {
        const res = await axios.get(`${API_BASE}/api/product/${encodeURIComponent(id)}`);
        result.push({ id, ok: true, data: res.data });
      } catch (e) {
        result.push({ id, ok: false, error: "取得失敗" });
      }
    }
    setItems(result);
    setLoading(false);
  };

  const copyUrl = async (url) => {
    try {
      await navigator.clipboard.writeText(url);
      alert("URLをコピーしました");
    } catch {
      alert("コピーに失敗しました");
    }
  };

  // SVG QR を PNG ダウンロード
  const downloadPng = (id) => {
    const svg = document.getElementById(`qr-${id}`);
    if (!svg) return;
    const xml = new XMLSerializer().serializeToString(svg);
    const svg64 = window.btoa(unescape(encodeURIComponent(xml)));
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      const size = 512;
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, size, size);
      ctx.drawImage(img, 0, 0, size, size);
      const link = document.createElement("a");
      link.download = `qr-${id}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    };
    img.src = "data:image/svg+xml;base64," + svg64;
  };

  return (
    <div style={{ padding: 16, maxWidth: 1000, margin: "0 auto" }}>
      <h1 style={{ marginBottom: 12 }}>管理画面（QR発行）</h1>

      <div style={{ display: "grid", gap: 8, marginBottom: 16 }}>
        <label>賞品ID（カンマ区切り）：</label>
        <input
          value={idsInput}
          onChange={(e) => setIdsInput(e.target.value)}
          placeholder="例: A001,B002,C003"
          style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }}
        />
        <button
          onClick={loadInfo}
          disabled={loading || prizeIds.length === 0}
          style={{
            width: 200,
            padding: "10px 14px",
            borderRadius: 8,
            border: "1px solid #2563eb",
            background: "#2563eb",
            color: "white",
            cursor: "pointer",
            fontWeight: 600,
          }}
        >
          {loading ? "読み込み中…" : "確認 & QR生成"}
        </button>
      </div>

      <div
        style={{
          display: "grid",
          gap: 16,
          gridTemplateColumns: "repeat(auto-fill, minmax(280px, 1fr))",
        }}
      >
        {items.map((it) => {
          const url = buildUrl(it.id);
          return (
            <div key={it.id} style={{ border: "1px solid #e5e7eb", borderRadius: 12, padding: 12 }}>
              <div style={{ fontWeight: 700, marginBottom: 4 }}>ID: {it.id}</div>
              {it.ok ? (
                <>
                  <div style={{ color: "#374151", fontSize: 13, marginBottom: 8 }}>
                    {it.data.prizeName}
                    <br />
                    公開予定（JST）：{it.data.resultTimeJST || "未設定"}
                  </div>
                  <div style={{ background: "white", padding: 8, borderRadius: 8, display: "grid", placeItems: "center" }}>
                    <QRCode id={`qr-${it.id}`} value={url} size={220} />
                  </div>
                  <div style={{ fontSize: 12, marginTop: 8, wordBreak: "break-all" }}>
                    {url}
                  </div>
                  <div style={{ display: "flex", gap: 8, marginTop: 8 }}>
                    <button
                      onClick={() => copyUrl(url)}
                      style={{ padding: "8px 10px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}
                    >
                      URLコピー
                    </button>
                    <button
                      onClick={() => downloadPng(it.id)}
                      style={{ padding: "8px 10px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}
                    >
                      PNG保存
                    </button>
                  </div>
                </>
              ) : (
                <div style={{ color: "crimson" }}>商品情報の取得に失敗しました</div>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

---

## 3) ルーティング（トップ＝参加者 / `/admin`＝管理）
`App.jsx` をルーター化します。

### **丸ごと上書き**：`/Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/App.jsx`
```jsx
import React from "react";
import { BrowserRouter, Routes, Route, Link, useParams } from "react-router-dom";
import Participant from "./Participant";
import Admin from "./Admin";

// /product/:id に来た時に Participant へ渡すラッパー
function ProductRoute() {
  const { id } = useParams();
  return <Participant initialPrizeId={id} />;
}

export default function App() {
  return (
    <BrowserRouter>
      <div style={{ padding: 16 }}>
        <header style={{ display: "flex", gap: 12, alignItems: "center", marginBottom: 12 }}>
          <h2 style={{ margin: 0 }}>コミケ抽選アプリ</h2>
          <nav style={{ display: "flex", gap: 8 }}>
            <Link to="/">参加者ページ</Link>
            <Link to="/admin">管理（QR発行）</Link>
          </nav>
        </header>

        <Routes>
          {/* 参加者ページ（?prizeId= を読む） */}
          <Route path="/" element={<Participant />} />
          {/* /product/A001 のようなパスでもOK */}
          <Route path="/product/:id" element={<ProductRoute />} />
          {/* 管理画面 */}
          <Route path="/admin" element={<Admin />} />
          {/* 404 */}
          <Route path="*" element={<div style={{ padding: 16 }}>ページが見つかりません。</div>} />
        </Routes>
      </div>
    </BrowserRouter>
  );
}
```

> `react-router-dom` は既に入っているはずですが、未導入なら：  
> `npm install react-router-dom`

---

## 4) （任意）環境変数でURLを管理
**新規作成 or 追記**：`/Users/m-aoki/Downloads/comiket-lottery-app/frontend/.env`  
**以下を“丸ごとコピペして保存”してください。**
```
REACT_APP_API_BASE=http://localhost:3001
REACT_APP_FRONT_BASE=http://localhost:3000
```
> `.env` を編集したら **`npm start` を再起動**してください。

---

## 5) 起動と確認
```bash
# バックエンド
cd "/Users/m-aoki/Downloads/comiket-lottery-app/backend"
PORT=3001 node index.js

# フロント
cd "/Users/m-aoki/Downloads/comiket-lottery-app/frontend"
npm start
```

- **参加者ページ**：  
  - `http://localhost:3000/?prizeId=A001`  
  - or `http://localhost:3000/product/A001`
- **管理画面（QR発行）**：  
  - `http://localhost:3000/admin`  
  - 例：入力 `A001,B002` → 「確認 & QR生成」→ 各賞品のQR表示／URLコピー／PNG保存

---

## 補足（よくある質問）
- **公開前なのにフォームが出ない**  
  → 正常です。公開前はカウントダウンだけ表示。テストは `lotteryData.js` の `resultTimeJST` を一時的に「過去」にしてください。  
- **別PCのスマホで確認したい**  
  → `FRONT_BASE` を `http://<あなたのLAN IP>:3000` にして再起動。スマホは同一LANでアクセス。  
- **QRのURLはどう印刷？**  
  → 管理画面の「PNG保存」で画像化 → 印刷に貼り付け。

---

ここまでできれば、**運用に必要な「参加者ページ」と「管理（QR配布）」がローカルで完成**です。  
次は本番（Render）一体運用 or スプレッドシート連携どちらから行きますか？

---

user:
Compiled with problems:
×
ERROR in ./src/App.jsx 7:0-40
Module not found: Error: Can't resolve './Participant' in '/Users/m-aoki/Downloads/comiket-lottery-app/frontend/src'

---

system:


---

assistant:
エラーの原因はシンプルで、`App.jsx` から読み込もうとしている **`./Participant`** というファイルがフロントエンドの `src` フォルダに存在しないためです。  

---

## 確認ポイント
1. **ファイル作成済みか？**  
   `frontend/src/Participant.jsx` を作成しましたか？  
   → 作っていない場合は、新規作成してください。

2. **ファイル名のスペルと拡張子**  
   - ファイルは必ず `Participant.jsx`（Pは大文字）  
   - 拡張子は `.jsx` です。`.js` や `.JSX` だと解決できません。

3. **ディレクトリ位置**  
   - 正しいパスは：
     ```
     /Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/Participant.jsx
     ```
   - `src` の直下に置く必要があります。

---

## 修正方法
もしまだ作っていなければ、以下をコピペで新規作成してください。  

### 新規作成コマンド（Mac ターミナル）
```bash
cat > "/Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/Participant.jsx" <<'EOF'
import React, { useEffect, useMemo, useState } from "react";
import axios from "axios";

const API_BASE = process.env.REACT_APP_API_BASE || "http://localhost:3001";

function fmtHMS(sec) {
  const s = Math.max(0, Math.floor(sec));
  const h = String(Math.floor(s / 3600)).padStart(2, "0");
  const m = String(Math.floor((s % 3600) / 60)).padStart(2, "0");
  const ss = String(Math.floor(s % 60)).padStart(2, "0");
  return `${h}:${m}:${ss}`;
}

export default function Participant({ initialPrizeId }) {
  const prizeId = useMemo(() => {
    const p = new URLSearchParams(window.location.search).get("prizeId");
    return p || initialPrizeId || "A001";
  }, [initialPrizeId]);

  const [prize, setPrize] = useState(null);
  const [loadingPrize, setLoadingPrize] = useState(true);
  const [error, setError] = useState("");

  const [entryNumber, setEntryNumber] = useState("");
  const [password, setPassword] = useState("");
  const [resultMsg, setResultMsg] = useState("");
  const [sending, setSending] = useState(false);

  const publishAt = useMemo(() => {
    if (!prize?.publishTimeParsedUTC) return null;
    const d = new Date(prize.publishTimeParsedUTC);
    return isNaN(d) ? null : d;
  }, [prize]);

  const [remainSec, setRemainSec] = useState(null);
  const isPublished = useMemo(() => {
    if (!publishAt) return true;
    return new Date() >= publishAt;
  }, [publishAt]);

  useEffect(() => {
    let timer;
    if (publishAt) {
      const tick = () => {
        const now = new Date();
        setRemainSec((publishAt.getTime() - now.getTime()) / 1000);
      };
      tick();
      timer = setInterval(tick, 1000);
    }
    return () => timer && clearInterval(timer);
  }, [publishAt]);

  useEffect(() => {
    setLoadingPrize(true);
    setError("");
    axios
      .get(`${API_BASE}/api/product/${encodeURIComponent(prizeId)}`)
      .then((res) => setPrize(res.data))
      .catch(() => setError("商品が見つかりません。"))
      .finally(() => setLoadingPrize(false));
  }, [prizeId]);

  const onSubmit = async (e) => {
    e.preventDefault();
    setResultMsg("");
    if (!entryNumber || !password) {
      setResultMsg("抽選番号とパスワードを入力してください。");
      return;
    }
    try {
      setSending(true);
      const res = await axios.post(`${API_BASE}/api/check`, {
        prizeId,
        entryNumber,
        password,
      });
      setResultMsg(res.data?.result ?? "結果を取得できませんでした。");
    } catch {
      setResultMsg("通信エラーが発生しました。");
    } finally {
      setSending(false);
    }
  };

  return (
    <div style={{ padding: 16, maxWidth: 520, margin: "0 auto" }}>
      <h1>抽選アプリ 🎲</h1>
      {loadingPrize ? (
        <div>読み込み中…</div>
      ) : error ? (
        <div style={{ color: "crimson" }}>{error}</div>
      ) : !prize ? (
        <div>データがありません。</div>
      ) : (
        <>
          <div>{prize.prizeName}</div>
          {!isPublished ? (
            <div>公開まで：{remainSec != null ? fmtHMS(remainSec) : "—"}</div>
          ) : (
            <form onSubmit={onSubmit}>
              <input
                value={entryNumber}
                onChange={(e) => setEntryNumber(e.target.value)}
                placeholder="抽選番号"
              />
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="パスワード"
              />
              <button type="submit" disabled={sending}>
                {sending ? "送信中…" : "結果を確認"}
              </button>
            </form>
          )}
          {resultMsg && <div>{resultMsg}</div>}
        </>
      )}
    </div>
  );
}
EOF
```

---

これを保存してから **再度 `npm start` を実行**すれば、エラーは解消するはずです。  

👉 質問：  
`Participant.jsx` を作った記憶はありますか？ それともまだ未作成でしたか？

---

user:
まだ未作成だったよ

---

system:


---

system:


---

assistant:
了解！では不足していたファイルを**新規作成**して一気に通します。  
（指示は “新規作成 / 丸ごと上書き” を明示します）

---

## 1) `Participant.jsx` を**新規作成**（参加者ページ）

ターミナルにコピペしてください：
```bash
cat > "/Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/Participant.jsx" <<'EOF'
import React, { useEffect, useMemo, useState } from "react";
import axios from "axios";

const API_BASE = process.env.REACT_APP_API_BASE || "http://localhost:3001";

function fmtHMS(sec) {
  const s = Math.max(0, Math.floor(sec));
  const h = String(Math.floor(s / 3600)).padStart(2, "0");
  const m = String(Math.floor((s % 3600) / 60)).padStart(2, "0");
  const ss = String(Math.floor(s % 60)).padStart(2, "0");
  return `${h}:${m}:${ss}`;
}

export default function Participant({ initialPrizeId }) {
  const prizeId = useMemo(() => {
    const p = new URLSearchParams(window.location.search).get("prizeId");
    return p || initialPrizeId || "A001";
  }, [initialPrizeId]);

  const [prize, setPrize] = useState(null);
  const [loadingPrize, setLoadingPrize] = useState(true);
  const [error, setError] = useState("");

  const [entryNumber, setEntryNumber] = useState("");
  const [password, setPassword] = useState("");
  const [resultMsg, setResultMsg] = useState("");
  const [sending, setSending] = useState(false);

  const publishAt = useMemo(() => {
    if (!prize?.publishTimeParsedUTC) return null;
    const d = new Date(prize.publishTimeParsedUTC);
    return isNaN(d) ? null : d;
  }, [prize]);

  const [remainSec, setRemainSec] = useState(null);
  const isPublished = useMemo(() => {
    if (!publishAt) return true;
    return new Date() >= publishAt;
  }, [publishAt]);

  useEffect(() => {
    let timer;
    if (publishAt) {
      const tick = () => {
        const now = new Date();
        setRemainSec((publishAt.getTime() - now.getTime()) / 1000);
      };
      tick();
      timer = setInterval(tick, 1000);
    }
    return () => timer && clearInterval(timer);
  }, [publishAt]);

  useEffect(() => {
    setLoadingPrize(true);
    setError("");
    axios
      .get(`${API_BASE}/api/product/${encodeURIComponent(prizeId)}`)
      .then((res) => setPrize(res.data))
      .catch(() => setError("商品が見つかりません。QRまたはURLを確認してください。"))
      .finally(() => setLoadingPrize(false));
  }, [prizeId]);

  const onSubmit = async (e) => {
    e.preventDefault();
    setResultMsg("");
    if (!entryNumber || !password) {
      setResultMsg("抽選番号とパスワードを入力してください。");
      return;
    }
    try {
      setSending(true);
      const res = await axios.post(`${API_BASE}/api/check`, {
        prizeId,
        entryNumber,
        password,
      });
      setResultMsg(res.data?.result ?? "結果を取得できませんでした。");
    } catch {
      setResultMsg("通信エラーが発生しました。時間を置いてお試しください。");
    } finally {
      setSending(false);
    }
  };

  return (
    <div style={{ padding: 16, maxWidth: 520, margin: "0 auto" }}>
      <h1>抽選アプリ 🎲</h1>

      {loadingPrize ? (
        <div>読み込み中…</div>
      ) : error ? (
        <div style={{ color: "crimson" }}>{error}</div>
      ) : !prize ? (
        <div>データがありません。</div>
      ) : (
        <>
          <div style={{ padding: 14, border: "1px solid #e5e7eb", borderRadius: 12, background: "#f9fafb", marginBottom: 14 }}>
            <div style={{ fontWeight: 700, marginBottom: 6 }}>{prize.prizeName}</div>
            <div style={{ fontSize: 13, color: "#374151" }}>
              公開予定（JST）：{prize.resultTimeJST || "未設定"}
            </div>
          </div>

          {!isPublished ? (
            <div style={{ padding: 16, border: "1px solid #f59e0b", borderRadius: 12, background: "#fffbeb" }}>
              <div style={{ fontWeight: 700, marginBottom: 6 }}>まだ結果は公開されていません ⏳</div>
              <div>公開まで：{remainSec != null ? fmtHMS(remainSec) : "—"}</div>
            </div>
          ) : (
            <form onSubmit={onSubmit} style={{ display: "grid", gap: 10, marginTop: 4 }}>
              <input
                value={entryNumber}
                onChange={(e) => setEntryNumber(e.target.value)}
                placeholder="抽選番号（例：001）"
                style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }}
              />
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="パスワード（例：1234）"
                style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }}
              />
              <button type="submit" disabled={sending} style={{ padding: "10px 14px", borderRadius: 8, border: "1px solid #2563eb", background: "#2563eb", color: "white", fontWeight: 600 }}>
                {sending ? "送信中…" : "結果を確認"}
              </button>
            </form>
          )}

          {resultMsg && (
            <div style={{ marginTop: 8, padding: 12, border: "1px solid #e5e7eb", borderRadius: 8, background: "#fff" }}>
              {resultMsg}
            </div>
          )}
        </>
      )}
    </div>
  );
}
EOF
```

---

## 2) `Admin.jsx` も**新規作成**（管理・QR発行）
※ これを作らないと、次に `Can't resolve './Admin'` エラーが出ます。

```bash
cat > "/Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/Admin.jsx" <<'EOF'
import React, { useMemo, useState } from "react";
import QRCode from "react-qr-code";
import axios from "axios";

const FRONT_BASE = process.env.REACT_APP_FRONT_BASE || "http://localhost:3000";
const API_BASE = process.env.REACT_APP_API_BASE || "http://localhost:3001";

export default function Admin() {
  const [idsInput, setIdsInput] = useState("A001");
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);

  const prizeIds = useMemo(
    () => idsInput.split(",").map((s) => s.trim()).filter(Boolean),
    [idsInput]
  );

  const buildUrl = (id) => `${FRONT_BASE}/?prizeId=${encodeURIComponent(id)}`;

  const loadInfo = async () => {
    setLoading(true);
    const result = [];
    for (const id of prizeIds) {
      try {
        const res = await axios.get(`${API_BASE}/api/product/${encodeURIComponent(id)}`);
        result.push({ id, ok: true, data: res.data });
      } catch {
        result.push({ id, ok: false, error: "取得失敗" });
      }
    }
    setItems(result);
    setLoading(false);
  };

  const copyUrl = async (url) => {
    try {
      await navigator.clipboard.writeText(url);
      alert("URLをコピーしました");
    } catch {
      alert("コピーに失敗しました");
    }
  };

  const downloadPng = (id) => {
    const svg = document.getElementById(`qr-${id}`);
    if (!svg) return;
    const xml = new XMLSerializer().serializeToString(svg);
    const svg64 = window.btoa(unescape(encodeURIComponent(xml)));
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      const size = 512;
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, size, size);
      ctx.drawImage(img, 0, 0, size, size);
      const link = document.createElement("a");
      link.download = `qr-${id}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    };
    img.src = "data:image/svg+xml;base64," + svg64;
  };

  return (
    <div style={{ padding: 16, maxWidth: 1000, margin: "0 auto" }}>
      <h1>管理画面（QR発行）</h1>

      <div style={{ display: "grid", gap: 8, marginBottom: 16 }}>
        <label>賞品ID（カンマ区切り）：</label>
        <input
          value={idsInput}
          onChange={(e) => setIdsInput(e.target.value)}
          placeholder="例: A001,B002,C003"
          style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }}
        />
        <button
          onClick={loadInfo}
          disabled={loading || prizeIds.length === 0}
          style={{ width: 220, padding: "10px 14px", borderRadius: 8, border: "1px solid #2563eb", background: "#2563eb", color: "white", fontWeight: 600 }}
        >
          {loading ? "読み込み中…" : "確認 & QR生成"}
        </button>
      </div>

      <div style={{ display: "grid", gap: 16, gridTemplateColumns: "repeat(auto-fill, minmax(280px, 1fr))" }}>
        {items.map((it) => {
          const url = buildUrl(it.id);
          return (
            <div key={it.id} style={{ border: "1px solid #e5e7eb", borderRadius: 12, padding: 12 }}>
              <div style={{ fontWeight: 700, marginBottom: 4 }}>ID: {it.id}</div>
              {it.ok ? (
                <>
                  <div style={{ color: "#374151", fontSize: 13, marginBottom: 8 }}>
                    {it.data.prizeName}
                    <br />
                    公開予定（JST）：{it.data.resultTimeJST || "未設定"}
                  </div>
                  <div style={{ background: "white", padding: 8, borderRadius: 8, display: "grid", placeItems: "center" }}>
                    <QRCode id={`qr-${it.id}`} value={url} size={220} />
                  </div>
                  <div style={{ fontSize: 12, marginTop: 8, wordBreak: "break-all" }}>{url}</div>
                  <div style={{ display: "flex", gap: 8, marginTop: 8 }}>
                    <button onClick={() => copyUrl(url)} style={{ padding: "8px 10px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}>URLコピー</button>
                    <button onClick={() => downloadPng(it.id)} style={{ padding: "8px 10px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}>PNG保存</button>
                  </div>
                </>
              ) : (
                <div style={{ color: "crimson" }}>商品情報の取得に失敗しました</div>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
}
EOF
```

必要パッケージが未インストールなら入れてください：
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/frontend"
npm install react-qr-code axios
```

---

## 3) `App.jsx` を**丸ごと上書き**（ルーティング）

```bash
cat > "/Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/App.jsx" <<'EOF'
import React from "react";
import { BrowserRouter, Routes, Route, Link, useParams } from "react-router-dom";
import Participant from "./Participant";
import Admin from "./Admin";

function ProductRoute() {
  const { id } = useParams();
  return <Participant initialPrizeId={id} />;
}

export default function App() {
  return (
    <BrowserRouter>
      <div style={{ padding: 16 }}>
        <header style={{ display: "flex", gap: 12, alignItems: "center", marginBottom: 12 }}>
          <h2 style={{ margin: 0 }}>コミケ抽選アプリ</h2>
          <nav style={{ display: "flex", gap: 8 }}>
            <Link to="/">参加者ページ</Link>
            <Link to="/admin">管理（QR発行）</Link>
          </nav>
        </header>

        <Routes>
          <Route path="/" element={<Participant />} />
          <Route path="/product/:id" element={<ProductRoute />} />
          <Route path="/admin" element={<Admin />} />
          <Route path="*" element={<div style={{ padding: 16 }}>ページが見つかりません。</div>} />
        </Routes>
      </div>
    </BrowserRouter>
  );
}
EOF
```

ルーターが未導入なら：
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/frontend"
npm install react-router-dom
```

---

## 4) （任意）環境変数ファイルを**新規作成/追記**
```bash
cat > "/Users/m-aoki/Downloads/comiket-lottery-app/frontend/.env" <<'EOF'
REACT_APP_API_BASE=http://localhost:3001
REACT_APP_FRONT_BASE=http://localhost:3000
EOF
```
> `.env` を作った/変えた場合は **`npm start` を再起動**。

---

## 5) 起動
```bash
# バックエンド
cd "/Users/m-aoki/Downloads/comiket-lottery-app/backend"
PORT=3001 node index.js

# フロント
cd "/Users/m-aoki/Downloads/comiket-lottery-app/frontend"
npm start
```

- 参加者ページ：`http://localhost:3000/?prizeId=A001` または `http://localhost:3000/product/A001`
- 管理（QR発行）：`http://localhost:3000/admin`

---

これで `Participant` と `Admin` の両方が解決し、画面が動くはずです。  
次は「スプレッドシート連携」や「Render本番デプロイ（1ポート運用）」にも進めます。どちらから行きますか？

---

user:
動いた。スプレッドシートじゃなくてWeb上でDB管理したい

---

system:


---

system:


---

assistant:
いいね！では **スプレッドシート無し**で、**Web上(DB)で管理**できる形に切り替えましょう。  
Render での運用を考えると、**SQLite（ファイル）**はデプロイで消えやすいので不向き。**Render Managed PostgreSQL（無料枠）**か **Neon/Supabase** の無料Postgresを使うのが安全です。ここでは **PostgreSQL** を前提に進めます。

---

# 全体像（やること）
1) **DBを用意**（Renderの無料Postgres か Neon など）  
2) **テーブル作成SQL** を流し込む  
3) **バックエンドをDB対応**（`node-postgres`）  
4) **管理用API（賞品/エントリーのCRUD）** を追加  
5) 既存の参加者ページはそのまま動作（データソースがDBになる）

---

## 0) なぜPostgres？
- Renderのファイルシステムは**エフェメラル**（再デプロイで消える）ので SQLite は✗  
- Postgres なら Render の**管理DB**や **Neon(無償)**で**永続化**できる  
- 将来「抽選履歴」「発行数集計」などにも拡張しやすい

---

## 1) Postgres を準備
- Render のダッシュボード → **Databases** → **New PostgreSQL**（Free）  
  または **Neon**（無料）で DB を作成  
- **接続文字列**（例：`postgres://user:pass@host:5432/dbname`）を控える  
  - ローカル用 `.env` と Render の環境変数に **`DATABASE_URL`** として設定します

**ローカルの `.env`（新規作成/上書き）**
```
# backend/.env
DATABASE_URL=postgres://<username>:<password>@<host>:<port>/<db>
PORT=3001
# テスト用（公開前ガードを無効化したい時だけ）
# FORCE_PUBLISH_ALL=1
```

> `.env` を作った/変更したら、バックエンドは再起動してください。

---

## 2) スキーマ（テーブル作成SQL）
**このSQLを DB に流し込んでください**（psql / RenderのSQLコンソールなどで実行）。

```sql
-- prizes: 賞品マスタ（公開時刻含む）
create table if not exists prizes (
  id text primary key,              -- 例: 'A001'
  name text not null,               -- 例: 'サンプル賞品A'
  result_time_jst text,             -- 'YYYY-MM-DD HH:MM' (JST表記の文字列)
  publish_time_utc timestamptz,     -- 上のJSTをUTCに変換して格納（任意）
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- entries: エントリー（参加者）
create table if not exists entries (
  id bigserial primary key,
  prize_id text references prizes(id) on delete cascade,
  entry_number text not null,       -- 例: '001'
  password text not null,           -- 例: '1234'（簡易用：今回は平文のまま）
  is_winner boolean default false,  -- 当選者かどうか（任意）
  unique (prize_id, entry_number)
);

-- 例データ
insert into prizes (id, name, result_time_jst, publish_time_utc)
values
  ('A001', 'サンプル賞品A', '2025-08-20 12:00', '2025-08-20 03:00:00+00')
on conflict (id) do nothing;

insert into entries (prize_id, entry_number, password, is_winner)
values
  ('A001', '001', '1234', true),
  ('A001', '002', '5678', false)
on conflict do nothing;
```

> 既にローカルで A001 をテストしていた内容に合わせています。公開時刻は後から更新可能です。

---

## 3) バックエンドを DB 対応にする

### 3-1) 依存を追加
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/backend"
npm install pg dotenv
```

### 3-2) `backend/index.js` を**丸ごと上書き**してください
（既存API互換：`GET /api/product/:prizeId` と `POST /api/check` を DB 参照に変更）

```js
// /Users/m-aoki/Downloads/comiket-lottery-app/backend/index.js
const express = require("express");
const cors = require("cors");
const bodyParser = require("body-parser");
const { Pool } = require("pg");
const path = require("path");
require("dotenv").config();

const app = express();
app.use(cors());
app.use(bodyParser.json());

const PORT = process.env.PORT || 3001;
const FORCE_PUBLISH_ALL = process.env.FORCE_PUBLISH_ALL === "1";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

// JST文字列('YYYY-MM-DD HH:MM')→UTC Date（簡易）
function jstToUtcDate(jstStr) {
  if (!jstStr) return null;
  // JST (UTC+9) を UTC に変換
  // 入力は "YYYY-MM-DD HH:MM"
  const [ymd, hm] = jstStr.split(" ");
  const [year, month, day] = ymd.split("-").map(Number);
  const [hour, minute] = hm.split(":").map(Number);
  // Date.UTC はUTCとして扱うので、JST→UTCにするため hour-9
  return new Date(Date.UTC(year, month - 1, day, (hour ?? 0) - 9, minute ?? 0, 0));
}

// 便利クエリ
async function getPrize(prizeId) {
  const { rows } = await pool.query(
    `select id, name, result_time_jst, publish_time_utc from prizes where id=$1`,
    [prizeId]
  );
  return rows[0] || null;
}

async function getEntry(prizeId, entryNumber) {
  const { rows } = await pool.query(
    `select id, prize_id, entry_number, password, is_winner
       from entries
      where prize_id=$1 and entry_number=$2`,
    [prizeId, entryNumber]
  );
  return rows[0] || null;
}

// 公開前判定
function isPublishedNow(prize) {
  if (FORCE_PUBLISH_ALL) return true;
  // DBにpublish_time_utcが無い場合は、result_time_jstから計算
  let publishUtc = prize.publish_time_utc ? new Date(prize.publish_time_utc) : null;
  if (!publishUtc && prize.result_time_jst) {
    publishUtc = jstToUtcDate(prize.result_time_jst);
  }
  if (!publishUtc || isNaN(publishUtc)) return true; // 未設定は公開扱い
  const now = new Date();
  return now >= publishUtc;
}

// ヘルス
app.get("/api/now", (_req, res) => {
  res.json({ now_utc: new Date().toISOString() });
});

// 参加者向け：賞品情報
app.get("/api/product/:prizeId", async (req, res) => {
  try {
    const prizeId = req.params.prizeId;
    const prize = await getPrize(prizeId);
    if (!prize) return res.status(404).json({ error: "not_found" });

    // 表示用
    res.json({
      prizeId: prize.id,
      prizeName: prize.name,
      resultTimeJST: prize.result_time_jst || null,
      publishTimeParsedUTC: prize.publish_time_utc || (prize.result_time_jst ? jstToUtcDate(prize.result_time_jst).toISOString() : null),
    });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "server_error" });
  }
});

// 結果チェック
app.post("/api/check", async (req, res) => {
  try {
    const { prizeId, entryNumber, password } = req.body || {};
    if (!prizeId || !entryNumber || !password) {
      return res.json({ result: "入力が不足しています。" });
    }

    const prize = await getPrize(prizeId);
    if (!prize) return res.json({ result: "該当の賞品が見つかりません。" });

    if (!isPublishedNow(prize)) {
      return res.json({ result: "まだ結果発表前です。公開時刻をお待ちください。" });
    }

    const entry = await getEntry(prizeId, entryNumber);
    if (!entry || entry.password !== password) {
      return res.json({ result: "エントリー番号またはパスワードが正しくありません。" });
    }

    if (entry.is_winner) {
      return res.json({ result: `🎉 おめでとうございます！「${prize.name}」に当選しました！` });
    } else {
      return res.json({ result: `残念…「${prize.name}」は落選でした。` });
    }
  } catch (e) {
    console.error(e);
    res.status(500).json({ result: "サーバーエラーが発生しました。" });
  }
});

/* ================= 管理用API（簡易） ================ */
// 賞品作成/更新
app.post("/api/admin/prize/upsert", async (req, res) => {
  try {
    const { id, name, resultTimeJST } = req.body || {};
    if (!id || !name) return res.status(400).json({ error: "missing_fields" });

    const publishUtc = resultTimeJST ? jstToUtcDate(resultTimeJST) : null;

    await pool.query(
      `insert into prizes (id, name, result_time_jst, publish_time_utc, updated_at)
       values ($1,$2,$3,$4, now())
       on conflict (id) do update
         set name=excluded.name,
             result_time_jst=excluded.result_time_jst,
             publish_time_utc=excluded.publish_time_utc,
             updated_at=now()`,
      [id, name, resultTimeJST || null, publishUtc ? publishUtc.toISOString() : null]
    );

    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "server_error" });
  }
});

// エントリー登録(複数)
app.post("/api/admin/entries/bulk", async (req, res) => {
  try {
    const { prizeId, entries } = req.body || {};
    if (!prizeId || !Array.isArray(entries)) return res.status(400).json({ error: "bad_request" });

    const client = await pool.connect();
    try {
      await client.query("begin");
      for (const e of entries) {
        await client.query(
          `insert into entries (prize_id, entry_number, password, is_winner)
           values ($1,$2,$3,$4)
           on conflict (prize_id, entry_number) do update
             set password=excluded.password, is_winner=excluded.is_winner`,
          [prizeId, e.entryNumber, e.password, !!e.isWinner]
        );
      }
      await client.query("commit");
    } catch (e) {
      await client.query("rollback");
      throw e;
    } finally {
      client.release();
    }
    res.json({ ok: true, count: entries.length });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "server_error" });
  }
});

/* ==============  本番で1ポート配信したい場合の静的配信  ============== */
/*
// フロントのbuildを配る運用にするなら、frontend/build を配信
const buildPath = path.join(__dirname, "..", "frontend", "build");
app.use(express.static(buildPath));
app.get("*", (_req, res) => {
  res.sendFile(path.join(buildPath, "index.html"));
});
*/

app.listen(PORT, () => {
  console.log(`Lottery backend (DB) running on port ${PORT}`);
});
```

> 既存の `lotteryData.js` は不要になります（参照を削除）。

---

## 4) 管理APIの使い方（テスト）
**賞品の登録/更新**
```bash
curl -X POST http://localhost:3001/api/admin/prize/upsert \
  -H "Content-Type: application/json" \
  -d '{"id":"A001","name":"サンプル賞品A","resultTimeJST":"2025-08-20 12:00"}'
```

**エントリーの一括投入**
```bash
curl -X POST http://localhost:3001/api/admin/entries/bulk \
  -H "Content-Type: application/json" \
  -d '{
    "prizeId":"A001",
    "entries":[
      {"entryNumber":"001","password":"1234","isWinner":true},
      {"entryNumber":"002","password":"5678","isWinner":false}
    ]
  }'
```

**フロントからの利用はそのまま**  
- 参加者URL例：`http://localhost:3000/?prizeId=A001`  
- 公開前はカウントダウン、公開後にフォーム→当落表示

---

## 5) Render での設定（本番時）
- **Web Service（backend）**  
  - `DATABASE_URL` を Render のダッシュボードに設定  
  - （フロントを同居させるなら）`npm run build` して `express.static` で配る構成に  
- **Static Site（frontend）** or 同居  
  - 同居するなら `REACT_APP_API_BASE` は空でもOK（相対 `/api/...` で叩けるように調整可能）

---

## 6) 次の拡張候補
- 管理画面（Web）で **賞品/エントリーをGUIでCRUD**  
- エントリーCSVのアップロード（管理画面から）  
- 当選数の制御（抽選ロジックをDB側で）  
- 管理者ログイン（Basic認証 or Auth0/Supabase Auth）

---

ここまでで、**Web上のDB（Postgres）で管理**する土台が完成します。  
このまま「管理画面（WebでCRUD）」も実装に入りますか？ それともまず DB 接続・API 動作を通してからにしますか？

---

user:
Render のダッシュボード の場所から説明して

---

system:


---

tool:


---

assistant:
はい、Render ダッシュボードを使った PostgreSQL データベースの設定について、具体的な手順を丁寧にご案内します。

---

##  Render ダッシュボードから PostgreSQL データベースを作成する手順

1. **Render にログインしてダッシュボードを開く。**

2. 画面右上の「`+ New`」ボタンをクリックし、表示されるドロップダウンで **「Postgres」** を選びます。  
   citeturn0search0turn0search10

3. **データベース作成フォーム**が表示されます。次のように入力／選択しましょう：  
   - **Name**：わかりやすい名前をつけてください（後から変更可能）  
   - **Region**：フロント／バックエンドと同じ地域を選ぶと通信が安定します  
   - **PostgreSQL Version**：デフォルトで大丈夫です（13～17が選択可）  
   - **Instance type**：**「Free」** を選択（無料枠）  
   - **Initial storage**：1GB以上を選択（Freeでは1GBの制限あり）  
   最後に **Create Database** をクリックすると、作成が始まります。  
   citeturn0search0turn0search10

4. 作成中に画面が遷移し、データベース一覧に新しいインスタンスが追加されます。状態が「Available」になるまで少し待ちましょう。

---

## 作成後の操作：Connection 情報の取得

1. 新しく作ったデータベースの行をクリックして、**データベース詳細ページ**に移動します。

2. 画面右上にある **「Connect」** メニューを開き、  
   - **Internal URL**（Renderサービス間で安全に接続可能）  
   - **External URL**（ローカルや他サービスからアクセスするとき用）  
   の両方が表示されます。  
   どちらもコピーしておきます。  
   citeturn0search0

3. ローカルで使う `.env` に次のように貼り付けてください：

   ```
   DATABASE_URL=<ここに Internal または External の URL>
   ```

   バックエンドで以下のように `dotenv` を使って読み込むようにしておきましょう：

   ```js
   require("dotenv").config();
   const pool = new Pool({ connectionString: process.env.DATABASE_URL });
   ```

4. バックエンドサービス（Web Service）を設定する際には、**同じリージョンを選んでおくと、`Internal URL` で速く接続できます**。  
   citeturn0search0

---

##  まとめ

- Render の「`+ New > Postgres`」から簡単に有料なしでDB作成できる  
- 内部と外部用 URL が用意されているので使い分けが可能  
- フロント・バックエンドと同リージョンに揃えるのがパフォーマンス最適化につながる  
  citeturn0search0turn0search10

---

次は、実際にこの `DATABASE_URL` を使ってアプリを動かしてみましょう。  
ご希望であれば、環境変数の設定とバックエンドへの反映手順もご案内します！

---

user:
データベースがAvailableになった、名前は comiket-lottery-app_DB

---

system:


---

system:


---

assistant:
おっ、**`comiket-lottery-app_DB` が Available** になったのナイスです！  
この後は「接続情報を取得 → スキーマ作成 → バックエンドをDB対応 → 動作確認」の順でいきます。すべて**コピペできる形**で書きます。

---

# 1) 接続情報（Connection）をコピー

1. Render ダッシュボードでデータベース **comiket-lottery-app_DB** をクリック  
2. 右上の **Connect** を開く  
   - **Internal Database URL**（Render 内部から接続用・推奨）  
   - **External Database URL**（ローカルPCから接続用）  
   の両方を控えてください。

> ローカル開発では **External** を、Render の Web Service からは **Internal** を使うのが基本です。

---

# 2) スキーマ作成（テーブル作成＆サンプル投入）

方法は2通りあります。どちらか好きな方で。

## 方法A：Render の SQL コンソールで実行（簡単）
データベース詳細ページの **“SQL”** タブ（または “pSQL Shell”）から、下記を**丸ごと貼り付けて実行**してください。

```sql
-- prizes: 賞品マスタ（公開時刻含む）
create table if not exists prizes (
  id text primary key,
  name text not null,
  result_time_jst text,
  publish_time_utc timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- entries: エントリー（参加者）
create table if not exists entries (
  id bigserial primary key,
  prize_id text references prizes(id) on delete cascade,
  entry_number text not null,
  password text not null,
  is_winner boolean default false,
  unique (prize_id, entry_number)
);

-- 例データ（必要なら）
insert into prizes (id, name, result_time_jst, publish_time_utc)
values
  ('A001', 'サンプル賞品A', '2025-08-20 12:00', '2025-08-20 03:00:00+00')
on conflict (id) do nothing;

insert into entries (prize_id, entry_number, password, is_winner)
values
  ('A001', '001', '1234', true),
  ('A001', '002', '5678', false)
on conflict do nothing;
```

## 方法B：ローカルの `psql` で実行
```bash
# External Database URL を使います（例）
export DATABASE_URL="postgres://<user>:<pass>@<host>:5432/<db>"

# psql が入っていなければインストール（macなら brew install libpq && brew link --force libpq）
psql "$DATABASE_URL" -c 'select now();'   # 接続テスト
psql "$DATABASE_URL" <<'SQL'
-- ↑ 上のSQLと同一。ここに「方法A」のSQLを貼って実行
SQL
```

---

# 3) バックエンドを DB 接続に切り替え

## 3-1) 依存追加（初回のみ）
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/backend"
npm install pg dotenv
```

## 3-2) 環境変数ファイルを作成/更新（ローカル用）
**新規作成または上書き：** `/Users/m-aoki/Downloads/comiket-lottery-app/backend/.env`  
（**丸ごと**貼り付けてください。`<...>` はあなたの External URL に置き換え）

```
DATABASE_URL=postgres://<user>:<pass>@<host>:5432/<db>
PORT=3001
# テストで公開前ガードを無効化したい時だけ
# FORCE_PUBLISH_ALL=1
```

> `.env` を更新したら、バックエンドは**再起動**が必要です。

## 3-3) `index.js` を DB 版に差し替え
前のやり取りどおり、**DB対応版の `index.js` を丸ごと上書き**してください（もう反映済みならこの手順はスキップでOK）。  
※ 必要ならもう一度お送りします。

---

# 4) ローカルで起動 & 動作確認

## 4-1) バックエンド（3001）
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/backend"
PORT=3001 node index.js
# => Lottery backend (DB) running on port 3001
```

### 管理APIでデータ投入（任意・再実行OK）
```bash
# 賞品の登録/更新
curl -X POST http://localhost:3001/api/admin/prize/upsert \
  -H "Content-Type: application/json" \
  -d '{"id":"A001","name":"サンプル賞品A","resultTimeJST":"2025-08-20 12:00"}'

# エントリーの一括登録
curl -X POST http://localhost:3001/api/admin/entries/bulk \
  -H "Content-Type: application/json" \
  -d '{
    "prizeId":"A001",
    "entries":[
      {"entryNumber":"001","password":"1234","isWinner":true},
      {"entryNumber":"002","password":"5678","isWinner":false}
    ]
  }'
```

### 参加者向けAPIの確認
```bash
# 商品情報取得
curl http://localhost:3001/api/product/A001

# 結果確認
curl -X POST http://localhost:3001/api/check \
  -H "Content-Type: application/json" \
  -d '{"prizeId":"A001","entryNumber":"001","password":"1234"}'
```

## 4-2) フロントエンド（3000）
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/frontend"
# （必要なら）.env に API ベースを明示
# echo 'REACT_APP_API_BASE=http://localhost:3001' > .env
npm start
```

- 参加者ページ：  
  `http://localhost:3000/?prizeId=A001`（公開前はカウントダウン／公開後にフォーム）
- 管理画面（QR発行）：  
  `http://localhost:3000/admin`

---

# 5) Render にも環境変数を設定（デプロイ時）

- **Web Service（バックエンド）** の **Environment** に次を追加  
  - `DATABASE_URL` → **Internal Database URL**（同リージョンなら高速＆安全）  
  - `PORT` → 3001（Render は自動で `PORT` を割り当てるので `process.env.PORT` 優先でもOK）
  - （必要に応じて）`FORCE_PUBLISH_ALL=1` は本番では **オフ** に

- **Front（Static Site）** なら  
  - ビルド時に `REACT_APP_API_BASE` を本番のバックエンドURLに  
  - もしくは、バックエンドで `frontend/build` を配って**1ポート運用**にする構成もOK

---

## 次にやること（どちらにします？）
- 🔧 **管理画面から賞品・エントリーをGUIでCRUD**（Webで完結）  
- ☁️ **Render 本番デプロイ（1ポート or 2ポート）** の設定を仕上げ

どちらから進めますか？必要なら、**今の `index.js` をDB対応版に丸ごと上書きする手順**を、もう一度そのまま貼り付けます。

---

user:
internal = postgresql://comiket_lottery_app_db_user:MAIa8lsYjxfkvoZjxTy63VJdGcjWFvUl@dpg-d2h9i2ur433s738316hg-a/comiket_lottery_app_db

---

system:


---

system:


---

assistant:
グッド！その **Internal URL** をバックエンドの接続先に使いましょう（Render内からの接続用。SSL設定不要）。

## 1) `.env` を作成（**丸ごと上書き**）
場所：`/Users/m-aoki/Downloads/comiket-lottery-app/backend/.env`
```
DATABASE_URL=postgresql://comiket_lottery_app_db_user:MAIa8lsYjxfkvoZjxTy63VJdGcjWFvUl@dpg-d2h9i2ur433s738316hg-a/comiket_lottery_app_db
PORT=3001
# テスト用（公開前ガード無効化したい時だけ）
# FORCE_PUBLISH_ALL=1
```
> 注意：**このURLは秘密情報**です。GitHubにコミットしないよう `.gitignore` に `.env` が入っていることを確認してください。

## 2) 依存確認（未実施なら一度だけ）
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/backend"
npm install pg dotenv
```

## 3) スキーマ作成（テーブル作成）  
Render の DB 詳細ページ → **SQL** タブで、次を**丸ごと実行**してください：

```sql
create table if not exists prizes (
  id text primary key,
  name text not null,
  result_time_jst text,
  publish_time_utc timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists entries (
  id bigserial primary key,
  prize_id text references prizes(id) on delete cascade,
  entry_number text not null,
  password text not null,
  is_winner boolean default false,
  unique (prize_id, entry_number)
);

-- サンプル（必要なら）
insert into prizes (id, name, result_time_jst, publish_time_utc)
values
  ('A001', 'サンプル賞品A', '2025-08-20 12:00', '2025-08-20 03:00:00+00')
on conflict (id) do nothing;

insert into entries (prize_id, entry_number, password, is_winner)
values
  ('A001', '001', '1234', true),
  ('A001', '002', '5678', false)
on conflict do nothing;
```

## 4) バックエンドの起動（ローカル）
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/backend"
PORT=3001 node index.js
# => Lottery backend (DB) running on port 3001
```

> もしまだ **DB対応版 `index.js`** に置き換えていなければ、すぐ用意できます。必要なら「index.js を丸ごと上書きしたい」と言ってください。すぐ貼ります。

## 5) API動作確認（ローカル）
```bash
# ヘルス
curl http://localhost:3001/api/now

# 商品情報
curl http://localhost:3001/api/product/A001

# 結果確認
curl -X POST http://localhost:3001/api/check \
  -H "Content-Type: application/json" \
  -d '{"prizeId":"A001","entryNumber":"001","password":"1234"}'
```

## 6) フロント（参加者/管理）はそのまま
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/frontend"
# 必要なら .env に API ベースを明示
# REACT_APP_API_BASE=http://localhost:3001
npm start
```
- 参加者：`http://localhost:3000/?prizeId=A001`
- 管理（QR発行）：`http://localhost:3000/admin`

---

### よくあるハマり
- **External URL を `.env` に入れてローカルから接続**／**Internal URL を Render のWebサービスで使用**が基本。  
  いまはローカル動作なので External でもOKですが、**Render上のWebサービスでは Internal**を使ってください。
- パスワードに記号がある場合は **URLエンコード**が必要（今回のは英数のみでOK）。
- `.env` を変更したら **バックエンド再起動**が必要。

ここまで終わったら、`/api/product/A001` と `/api/check` がDB経由で動きます。もし `index.js` のDB版が未適用なら、今すぐ貼り出します！

---

user:
Render の DB 詳細ページ → SQL タブ ってどこ？

---

system:


---

assistant:
なるほど 👍 Render の管理画面はちょっと分かりづらいので、順番に説明しますね。  

---

## Render の DB 詳細ページ → SQL タブの場所

1. **Render ダッシュボードにログイン**
   - https://dashboard.render.com  
   にアクセスして、アカウントにログインします。

2. **左側メニュー → Databases をクリック**
   - Deploys, Services, Cron Jobs などの一覧の中に **Databases** があります。
   - そこに、作成済みの **`comiket-lottery-app_DB`** が出ているはずです。

3. **該当のDB名 (`comiket-lottery-app_DB`) をクリック**
   - すると DB の詳細ページが開きます。
   - 「Info」「Connections」「Metrics」などのタブが上部に並んでいます。

4. **「SQL」タブをクリック**
   - このタブを選ぶと、ブラウザ上で直接 SQL を入力・実行できるエディタが表示されます。
   - ここに、先ほどお伝えした **CREATE TABLE 〜** のスクリプトを貼り付けて **Run** を押せば、テーブルが作成されます。

---

## ポイント
- 「Info」タブでは Internal / External 接続文字列（`postgresql://...`）が確認できます。
- 「SQL」タブで初期化スクリプトを流しておくと、外部のツール（psql, DBeaver, TablePlus など）を使わずにセットアップできます。
- もし SQL タブが見つからない場合は **右上の「⋮」メニュー**にあることもあります。

---

👉 ここまでで「SQL」タブを開けそうですか？  
もし Render のUI上で見つからなければ、ローカルから `psql` で直接接続する方法も説明できます。どっちで進めますか？

---

user:
{"content_type":"image_asset_pointer","asset_pointer":"file-service://file-BHb3dRJwLJvtuxByWVFvjm","size_bytes":233929,"width":1282,"height":992,"fovea":null,"metadata":{"dalle":null,"gizmo":null,"generation":null,"container_pixel_height":null,"container_pixel_width":null,"emu_omit_glimpse_image":null,"emu_patches_override":null,"lpe_keep_patch_ijhw":null,"sanitized":true,"asset_pointer_link":null,"watermarked_asset_pointer":null}}

---

assistant:
スクショありがとうございます！📝  
Render のダッシュボード画面を見たところ、「SQL タブ」が無いのは **UI の変更**によるものです。今の Render では「SQL タブ」は削除されていて、代わりに以下の方法でデータベースにアクセスします。

---

## 1. 「Connect」ボタンを使う
画面右上にある **Connect ▼** をクリックしてください。  
そこに「psql で接続」「外部ツールから接続」「Connection Info」などのオプションが出ます。

- **psql コマンドを使う場合**:  
  ```
  psql "postgresql://comiket_lottery_app_db_user:パスワード@dpg-xxx/comiket_lottery_app_db"
  ```
  という接続文字列をコピーして、Mac のターミナルで実行します。

- **GUI ツール（例: TablePlus, DBeaver）を使う場合**:  
  Connection Info をコピーして、ツールに貼り付けて接続できます。

---

## 2. Render の Web Console を使う方法
「SQL タブ」の代わりに **Shell (psql)** をブラウザで開く仕組みになっています。

手順:
1. 「Connect ▼」をクリック
2. 「psql in browser」または「psql shell」みたいな項目があるので選択
3. ブラウザ上で SQL を直接打てる画面が開きます

---

## 3. 最初にやるべき SQL
接続できたら、まずはテーブルを作りましょう。例:

```sql
CREATE TABLE participants (
  id SERIAL PRIMARY KEY,
  entry_number VARCHAR(10) NOT NULL,
  password VARCHAR(50) NOT NULL,
  prize_id VARCHAR(10) NOT NULL
);
```

---

👉 質問ですが：
- DB に接続するのは **ブラウザ上で操作したい**ですか？  
- それとも **ターミナル（psql コマンド）や GUI ツール**から接続したいですか？  

どちらかによって手順を具体的に書き分けます。

---

user:
RenderCLIインストールしろと言われてると思う
https://render.com/docs/cli?_gl=1*1fxl1vs*_gcl_au*MjAxMjQzNzUxMi4xNzU1NDA5MjU3*_ga*MTg1Mzk4MjQ2LjE3NTU0MDkyNTc.*_ga_QK9L9QJC5N*czE3NTU0ODcxMDIkbzUkZzEkdDE3NTU0ODcxMjkkajMzJGwwJGgw

---

assistant:
なるほど 👍 たしかに Render の新しい UI では **SQL タブが無くなっていて、代わりに CLI（コマンドラインツール）を使って接続**するように案内されます。  

以下の手順で進めれば OK です：

---

## Render CLI のインストール

### 1. Mac (Homebrew) の場合
ターミナルで以下を実行：

```bash
brew install render
```

### 2. Homebrew を使わない場合
直接バイナリをインストールできます：

```bash
curl -fsSL https://render.com/install.sh | bash
```

---

## Render CLI のログイン
Render CLI を入れたら、まずログイン：

```bash
render login
```

ブラウザが開くので Render アカウントで承認してください。

---

## DB に接続する
Render CLI 経由で Postgres に接続できます。

```bash
render db shell comiket-lottery-app_DB
```

これでブラウザで見えていた **comiket-lottery-app_DB** に対して直接 SQL を打てる状態になります。

---

## 例：テーブル作成
ログインできたら、例えばこんなコマンドを入力します：

```sql
CREATE TABLE participants (
  id SERIAL PRIMARY KEY,
  entry_number VARCHAR(10) NOT NULL,
  password VARCHAR(50) NOT NULL,
  prize_id VARCHAR(10) NOT NULL
);
```

---

👉 ここで質問です：
- あなたは **ブラウザ上で操作できる方が良い**ですか？  
- それとも **ターミナルから psql で直接操作するスタイル**が良いですか？  

どちらに合わせて次の説明を進めますよ。

---

user:
m-aoki@MacBook-Pro-20240703 backend % render db shell comiket-lottery-app_DB
Error: unknown command "db" for "render"
Run 'render --help' for usage.

---

assistant:
了解です。そのエラーメッセージ ("unknown command 'db'") は、Render CLIのバージョンが古かったり、機能がまだβだったりする場合に出ます。現時点では、**Render CLIでdb shell機能が正しく使えない可能性**があります。

以下2つの方法をご提案します。このうち使いやすい方法を選んで進めましょう。

---

## 方法①：psql（ローカル）または GUIツールを使って接続する — 推奨

Render側のSQL GUIが廃止された現在、もっとも確実なのは次の方法です：

1. **psql クライアント**（端末からPostgres接続）  
2. **GUIツール**（例：TablePlus, DBeaver, DataGripなど）

### psql を使う場合

ターミナルに下記の形式で実行してください（`<External DB URL>`にはRenderで表示されている External URL をそのままコピペ）：

```bash
psql "postgresql://comiket_lottery_app_db_user:MAIa8lsYjxfkvoZjxTy63VJdGcjWFvUl@dpg-d2h9i2ur433s738316hg-a/comiket_lottery_app_db"
```

もし psql が入っていなければ、macなら:

```bash
brew install libpq
brew link --force libpq
```

### GUIツールを使う場合

1. GUIアプリ（例：TablePlus、DBeaver等）を開く  
2. 「New Connection」→ 「PostgreSQL」を選択  
3. 以下の情報を貼り付ける：
   - **Host**: `dpg-d2h9i2ur433s738316hg-a`  
   - **Port**: 5432 (通常)  
   - **Username**: `comiket_lottery_app_db_user`  
   - **Password**: `MAIa8lsYjxfkvoZjxTy63VJdGcjWFvUl`  
   - **Database**: `comiket_lottery_app_db`  
4. 接続後、SQLタブでテーブルの作成・確認ができます。

---

## 方法②：Render CLI を最新化（手動インストール）

もし CLI でコマンドが使えたら便利ですよね。最新のCLIを導入する方法は以下の通り：

```bash
# まず既存があれば削除（Homebrew経由の場合）
brew uninstall render

# 最新 CLI を直接インストール
curl -fsSL https://render.com/install.sh | bash
```

その後、

```bash
render version
```

でバージョンを確認。  
CLIが新しくなると `render db shell comiket-lottery-app_DB` が使えるようになる可能性があります。ただし、現時点では安定して使えない場合も多いため、**方法①（psql or GUI）**をおすすめします。

---

##  まとめ

| 方法 | 推奨度 | 内容 |
|------|--------|------|
| **方法①：psql／GUIツール** | ⭐⭐⭐ | 確実かつ安定。今すぐテーブル作成可能。 |
| 方法②：最新 Render CLI | ⭐️⭐ | インストールが少し手間。CLIが動けば便利。 |

---

次にやることはどちらにしましょうか？

- ① psql または GUI で接続 → スキーマ作成 → テスト（コピペ用の SQL 指示準備可）  
- ② CLIのアップグレード（必要なら手順案内します）

---

user:
m-aoki@MacBook-Pro-20240703 backend % psql "postgresql://comiket_lottery_app_db_user:MAIa8lsYjxfkvoZjxTy63VJdGcjWFvUl@dpg-d2h9i2ur433s738316hg-a/comiket_lottery_app_db"
zsh: command not found: psql

---

assistant:
なるほど！  
`zsh: command not found: psql` ということは、Mac に **PostgreSQL クライアント（psql）** が入っていない状態です。Render の DB に接続するには、まずローカルに psql をインストールする必要があります。

---

## 🔧 macOSで psql をインストールする方法

### 方法①: Homebrew を使う（おすすめ）
もし Homebrew が使えるなら、以下のコマンドで PostgreSQL のクライアントだけをインストールできます。

```bash
brew install libpq
brew link --force libpq
```

これで `psql` コマンドが使えるようになります。確認は:

```bash
psql --version
```

---

### 方法②: PostgreSQL 本体をインストールする
クライアントだけでなくサーバーごと入れる場合は:

```bash
brew install postgresql
```

インストール後、同じく `psql --version` で確認できます。

---

### 方法③: GUIツールを使う（もしコマンドが難しい場合）
- **TablePlus**（シンプルでMac向け）
- **DBeaver**（無料・多機能）
- **pgAdmin4**（公式ツール）

どれも Render の接続情報（host, db, user, password, port=5432）を入力すれば GUI でDB操作が可能です。

---

## ✅ 次のステップ
1. まず `brew install libpq` を実行して `psql` を使えるようにする。  
2. その後、Renderが出してくれた接続URLを使って DB にログインする：

```bash
psql "postgresql://comiket_lottery_app_db_user:MAIa8lsYjxfkvoZjxTy63VJdGcjWFvUl@dpg-d2h9i2ur433s738316hg-a/comiket_lottery_app_db"
```

---

👉 先に Homebrew で `libpq` を入れるのをやってみますか？

---

user:
m-aoki@MacBook-Pro-20240703 backend % psql --version
psql (PostgreSQL) 17.6


---

system:


---

system:


---

assistant:
ナイス！`psql` 使える状態です 👍  
このまま **DB作成SQLの投入 → バックエンド接続 → 動作確認** まで一気に通します。すべてコピペOKで書きます。

---

## 1) Renderの **External Database URL** を取得
RenderのDB画面 右上 **Connect ▾ → External Database URL** をコピーしてください。  
（ローカルから接続する場合は **External** を使います。多くの場合 `?sslmode=require` が必要）

> もし External が分からない／未表示なら、手元のURL末尾に **`?sslmode=require`** を付けて試せます：
> ```
> postgresql://comiket_lottery_app_db_user:MAIa8lsYjxfkvoZjxTy63VJdGcjWFvUl@dpg-d2h9i2ur433s738316hg-a/comiket_lottery_app_db?sslmode=require
> ```

---

## 2) psql で接続（ターミナルにそのまま貼ってOK）

```bash
# 例：External URL を使って接続（?sslmode=require を付与）
psql "postgresql://comiket_lottery_app_db_user:MAIa8lsYjxfkvoZjxTy63VJdGcjWFvUl@dpg-d2h9i2ur433s738316hg-a/comiket_lottery_app_db?sslmode=require"
```

接続できたら、プロンプトが `comiket_lottery_app_db=>` のようになります。

---

## 3) スキーマ作成（テーブル & サンプル投入）
psql のプロンプトに**丸ごとコピペ**して実行してください：

```sql
-- prizes: 賞品マスタ
create table if not exists prizes (
  id text primary key,
  name text not null,
  result_time_jst text,         -- 'YYYY-MM-DD HH:MM' (JST)
  publish_time_utc timestamptz, -- 上のJSTをUTC化して入れてもOK（任意）
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- entries: エントリー
create table if not exists entries (
  id bigserial primary key,
  prize_id text references prizes(id) on delete cascade,
  entry_number text not null,
  password text not null,
  is_winner boolean default false,
  unique (prize_id, entry_number)
);

-- 動作確認用のサンプル（必要なら）
insert into prizes (id, name, result_time_jst, publish_time_utc)
values
  ('A001', 'サンプル賞品A', '2025-08-20 12:00', '2025-08-20 03:00:00+00')
on conflict (id) do nothing;

insert into entries (prize_id, entry_number, password, is_winner)
values
  ('A001', '001', '1234', true),
  ('A001', '002', '5678', false)
on conflict do nothing;

-- ざっと確認
\d prizes
\d entries
select count(*) from prizes;
select count(*) from entries;
```

> `\d` は psql のメタコマンド（テーブル定義表示）です。

---

## 4) バックエンドの接続先を設定

### 4-1) `.env`（ローカル用）を**丸ごと作成/上書き**
場所：`/Users/m-aoki/Downloads/comiket-lottery-app/backend/.env`

```
DATABASE_URL=postgresql://comiket_lottery_app_db_user:MAIa8lsYjxfkvoZjxTy63VJdGcjWFvUl@dpg-d2h9i2ur433s738316hg-a/comiket_lottery_app_db?sslmode=require
PORT=3001
# テストで公開前ガードを無効化する時だけ
# FORCE_PUBLISH_ALL=1
```

> ⚠️ 秘密情報なので `.env` は **Gitにコミットしない**（`.gitignore` に入っていることを確認）。

### 4-2) 依存が未導入なら一度だけ
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/backend"
npm install pg dotenv
```

### 4-3) バックエンド（DB対応版）を起動
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/backend"
PORT=3001 node index.js
# => Lottery backend (DB) running on port 3001
```

---

## 5) API 動作確認（ローカル）

```bash
# 現在時刻（ヘルス）
curl http://localhost:3001/api/now

# 商品情報（A001）
curl http://localhost:3001/api/product/A001

# 結果確認（当選の例）
curl -X POST http://localhost:3001/api/check \
  -H "Content-Type: application/json" \
  -d '{"prizeId":"A001","entryNumber":"001","password":"1234"}'
```

---

## 6) フロントからの確認（今まで通り）
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/frontend"
# 必要なら .env に API ベースを明示して再起動
# echo 'REACT_APP_API_BASE=http://localhost:3001' > .env
npm start
```
- 参加者ページ：`http://localhost:3000/?prizeId=A001`
- 管理（QR発行）：`http://localhost:3000/admin`

---

### もし接続でつまずいたら
- `psql: error: connection requires SSL` → URL末尾に `?sslmode=require` を付ける  
- 認証エラー → ユーザー名/パスワード/DB名のタイプミスを再確認  
- Render の DB 側で **Region** が異なると内部URLは使えません（ローカルは External を）

ここまで通れば、**DB管理（Postgres）に完全移行**できています。  
次は「Webの管理画面から CRUD（賞品/エントリー登録）をできるようにする」実装へ進めますか？

---

user:
external = postgresql://comiket_lottery_app_db_user:MAIa8lsYjxfkvoZjxTy63VJdGcjWFvUl@dpg-d2h9i2ur433s738316hg-a.oregon-postgres.render.com/comiket_lottery_app_db

---

system:


---

assistant:
いいですね！その **external** URL を使えばローカルから Render の Postgres に安全に接続できます。  

---

## 1. 接続テスト
まずは SSL モードを付けて `psql` で接続してみましょう：

```bash
psql "postgresql://comiket_lottery_app_db_user:MAIa8lsYjxfkvoZjxTy63VJdGcjWFvUl@dpg-d2h9i2ur433s738316hg-a.oregon-postgres.render.com/comiket_lottery_app_db?sslmode=require"
```

うまくいけばプロンプトが：

```
comiket_lottery_app_db=>
```

と表示されます。  

---

## 2. スキーマ作成
接続できたら、以下を psql の中に **丸ごとコピペ**してください：

```sql
-- 賞品テーブル
create table if not exists prizes (
  id text primary key,
  name text not null,
  result_time_jst text,
  publish_time_utc timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- エントリーテーブル
create table if not exists entries (
  id bigserial primary key,
  prize_id text references prizes(id) on delete cascade,
  entry_number text not null,
  password text not null,
  is_winner boolean default false,
  unique (prize_id, entry_number)
);

-- サンプルデータ
insert into prizes (id, name, result_time_jst, publish_time_utc)
values
  ('A001', 'サンプル賞品A', '2025-08-20 12:00', '2025-08-20 03:00:00+00')
on conflict (id) do nothing;

insert into entries (prize_id, entry_number, password, is_winner)
values
  ('A001', '001', '1234', true),
  ('A001', '002', '5678', false)
on conflict do nothing;
```

確認：

```sql
\d prizes
\d entries
select * from prizes;
select * from entries;
```

---

## 3. バックエンドから使う準備
バックエンドの `.env` に External URL を書いてください：

```
DATABASE_URL=postgresql://comiket_lottery_app_db_user:MAIa8lsYjxfkvoZjxTy63VJdGcjWFvUl@dpg-d2h9i2ur433s738316hg-a.oregon-postgres.render.com/comiket_lottery_app_db?sslmode=require
PORT=3001
```

---

## 4. 起動テスト

```bash
cd ~/Downloads/comiket-lottery-app/backend
npm install pg dotenv
PORT=3001 node index.js
```

別ターミナルで：

```bash
curl http://localhost:3001/api/product/A001
```

が返れば DB 接続成功です。

---

👉 ここまでで「Render DB をローカルのバックエンドから使える」状態になります。  

進めますか？それとも **psql の接続テスト**から一緒にやってみますか？

---

user:
comiket_lottery_app_db=> select * from prizes;
  id  |     name      | result_time_jst  |    publish_time_utc    |          created_at           |          updated_at           
------+---------------+------------------+------------------------+-------------------------------+-------------------------------
 A001 | サンプル賞品A | 2025-08-20 12:00 | 2025-08-20 03:00:00+00 | 2025-08-18 03:24:11.117654+00 | 2025-08-18 03:24:11.117654+00
(1 row)

comiket_lottery_app_db=> select * from entries;
 id | prize_id | entry_number | password | is_winner 
----+----------+--------------+----------+-----------
  1 | A001     | 001          | 1234     | t
  2 | A001     | 002          | 5678     | f
(2 rows)



---

system:


---

system:


---

assistant:
最高です！DBに初期データが入りました 🎉  
このまま **バックエンド→フロント** の順に DB 連携を通します。すべてコピペOKで書きます。

---

## 1) バックエンドをDBに接続

### 1-1) `.env` を作成/更新（**丸ごと上書き**）
場所：`/Users/m-aoki/Downloads/comiket-lottery-app/backend/.env`
```
DATABASE_URL=postgresql://comiket_lottery_app_db_user:MAIa8lsYjxfkvoZjxTy63VJdGcjWFvUl@dpg-d2h9i2ur433s738316hg-a.oregon-postgres.render.com/comiket_lottery_app_db?sslmode=require
PORT=3001
# テストで公開前ガードを無効化したい時だけ（本番は外す）
# FORCE_PUBLISH_ALL=1
```
> `.env` は **Gitにコミットしない**（`.gitignore` に `.env` が入っていることを確認）

### 1-2) 依存が未導入なら一度だけ
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/backend"
npm install pg dotenv
```

### 1-3) サーバ起動
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/backend"
PORT=3001 node index.js
# => Lottery backend (DB) running on port 3001
```

### 1-4) APIの疎通確認
別ターミナルで：
```bash
# 商品情報（DBから）
curl http://localhost:3001/api/product/A001

# 当落（A001 / 001 / 1234 は当選、002/5678 は落選）
curl -X POST http://localhost:3001/api/check \
  -H "Content-Type: application/json" \
  -d '{"prizeId":"A001","entryNumber":"001","password":"1234"}'
```

---

## 2) フロントから叩く

### 2-1) （必要なら）フロントの `.env` 作成/更新
場所：`/Users/m-aoki/Downloads/comiket-lottery-app/frontend/.env`
```
REACT_APP_API_BASE=http://localhost:3001
REACT_APP_FRONT_BASE=http://localhost:3000
```

> `.env` を変更したら **`npm start` を再起動**。

### 2-2) フロント起動
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/frontend"
npm start
```

### 2-3) ブラウザ確認
- 参加者：`http://localhost:3000/?prizeId=A001`  
  - 公開前：カウントダウン表示  
  - 公開後：フォーム表示 → 001/1234 で当選、002/5678 で落選
- 管理（QR発行）：`http://localhost:3000/admin`  
  - `A001` を入力 → 「確認 & QR生成」 → 賞品名/公開時刻/QR/URLコピー/PNG保存

---

## 3) 追加の管理API（任意：GUI前の準備）
データをAPIで追加・更新できます（GUI管理画面に繋げるための土台）。

```bash
# 賞品の登録/更新（resultTimeJST は 'YYYY-MM-DD HH:MM' JST）
curl -X POST http://localhost:3001/api/admin/prize/upsert \
  -H "Content-Type: application/json" \
  -d '{"id":"B002","name":"別の賞品B","resultTimeJST":"2025-08-25 10:00"}'

# エントリー一括投入
curl -X POST http://localhost:3001/api/admin/entries/bulk \
  -H "Content-Type: application/json" \
  -d '{
    "prizeId":"B002",
    "entries":[
      {"entryNumber":"101","password":"abcd","isWinner":true},
      {"entryNumber":"102","password":"efgh","isWinner":false}
    ]
  }'
```

その後、`http://localhost:3000/?prizeId=B002` で参加者ページが動くか確認できます。

---

## 4) トラブル時チェック
- `connection requires SSL` → URL末尾に `?sslmode=require`
- `ECONNREFUSED` → バックエンド（3001）が起動しているか
- 「公開前のまま」→ `prizes.result_time_jst` を現在より**過去**にする or 一時的に `FORCE_PUBLISH_ALL=1` で起動
- CORS → バックエンドが `cors()` を使っていること（今回の `index.js` は対応済み）

---

ここまで通れば、**DB（Render Postgres）運用に移行完了**です。  
次はどちらに進みますか？

1) 管理画面から **賞品/エントリーをGUIでCRUD**（CSVインポートも可）  
2) **Render本番デプロイ**（1ポート化でバックエンドからフロント配信）

---

user:
m-aoki@MacBook-Pro-20240703 backend % curl http://localhost:3001/api/product/A001
{"prizeId":"A001","prizeName":"サンプル賞品A","resultTimeJST":"2025-08-10 00:00","publishTimeParsedUTC":"2025-08-09T15:00:00.000Z"}%                                                m-aoki@MacBook-Pro-20240703 backend % curl -X POST http://localhost:3001/api/check \
  -H "Content-Type: application/json" \
  -d '{"prizeId":"A001","entryNumber":"001","password":"1234"}'
{"result":"🎉 おめでとうございます！「サンプル賞品A」に当選しました！"}%  

---

system:


---

system:


---

assistant:
動作バッチリです！🎉（`/api/product` 取得＆ `/api/check` 当選レス）  
この先は「Web上でDB管理」を仕上げるために、次のどれから進めますか？やりたい順に選んでください。必要なら即コードを丸ごと貼ります。

## 次の選択肢
1) **管理GUIで CRUD（賞品/エントリー）**  
   - 管理画面に「賞品作成/更新フォーム」「エントリー一括登録（CSV）」を追加  
   - いまの `Admin.jsx` を拡張して、API(`/api/admin/prize/upsert`, `/api/admin/entries/bulk`)に接続  
   - CSVは `entryNumber,password,isWinner` 形式でドラッグ&ドロップ or 貼り付け

2) **公開時刻のGUI編集 & 公開前/公開後の切替確認**  
   - 管理画面から `resultTimeJST` を編集 → バックエンドがUTCに変換保存  
   - 参加者画面のカウントダウン挙動を即確認できるように

3) **本番デプロイ（Render）一体運用**  
   - `frontend` を `npm run build` → `backend` の `express.static` で配信（1ポート）  
   - Render Web Service 環境変数：`DATABASE_URL(Internal)`, `NODE_VERSION`, など  
   - CORS不要・URLも相対化できて運用シンプル

4) **権限保護（簡易管理ログイン）**  
   - 管理画面に Basic 認証（Render の環境変数でID/PASS管理）  
   - あるいはCookieセッション付きのシンプルログイン

---

### すぐ取りかかれる最短コース（おすすめ）
- まず **(1) 管理GUI CRUD** を実装 → 運営がブラウザから直接データ投入できる状態に  
- 続いて **(3) Render一体運用** に切替（本番URL+QRで配布可能に）

👉 どれからいきます？  
「(1) 管理GUI CRUDで」と返してくれれば、**変更するファイルの“丸ごと上書き”コード**と**追加ファイル**を、コピペ手順つきで即お渡しします。

---

user:
すぐ取りかかれる最短コース（おすすめ）
	•	まず (1) 管理GUI CRUD を実装

---

system:


---

system:


---

assistant:
了解！最短で「ブラウザから賞品とエントリーを直接登録できる」管理GUIを入れます。  
以下は**そのままコピペで導入**できます。

---

# 1) `Admin.jsx` を**丸ごと上書きしてください**

```jsx
// /Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/Admin.jsx
import React, { useMemo, useState } from "react";
import axios from "axios";
import QRCode from "react-qr-code";

const API_BASE = process.env.REACT_APP_API_BASE || "http://localhost:3001";
const FRONT_BASE = process.env.REACT_APP_FRONT_BASE || "http://localhost:3000";

function Section({ title, children }) {
  return (
    <section style={{ border: "1px solid #e5e7eb", borderRadius: 12, padding: 16, marginBottom: 16 }}>
      <h2 style={{ margin: "0 0 8px 0", fontSize: 18 }}>{title}</h2>
      {children}
    </section>
  );
}

export default function Admin() {
  const [activeTab, setActiveTab] = useState("qr"); // 'qr' | 'prize' | 'entries'

  // ---------- ① QR発行 ----------
  const [idsInput, setIdsInput] = useState("A001");
  const prizeIds = useMemo(
    () => idsInput.split(",").map((s) => s.trim()).filter(Boolean),
    [idsInput]
  );
  const [qrItems, setQrItems] = useState([]);
  const [qrLoading, setQrLoading] = useState(false);

  const buildUrl = (id) => `${FRONT_BASE}/?prizeId=${encodeURIComponent(id)}`;

  const loadInfoForQR = async () => {
    setQrLoading(true);
    const result = [];
    for (const id of prizeIds) {
      try {
        const res = await axios.get(`${API_BASE}/api/product/${encodeURIComponent(id)}`);
        result.push({ id, ok: true, data: res.data });
      } catch {
        result.push({ id, ok: false, error: "取得失敗" });
      }
    }
    setQrItems(result);
    setQrLoading(false);
  };

  const copyUrl = async (url) => {
    try {
      await navigator.clipboard.writeText(url);
      alert("URLをコピーしました");
    } catch {
      alert("コピーに失敗しました");
    }
  };

  const downloadPng = (id) => {
    const svg = document.getElementById(`qr-${id}`);
    if (!svg) return;
    const xml = new XMLSerializer().serializeToString(svg);
    const svg64 = window.btoa(unescape(encodeURIComponent(xml)));
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      const size = 512;
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, size, size);
      ctx.drawImage(img, 0, 0, size, size);
      const link = document.createElement("a");
      link.download = `qr-${id}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    };
    img.src = "data:image/svg+xml;base64," + svg64;
  };

  // ---------- ② 賞品CRUD（作成/更新） ----------
  const [pzId, setPzId] = useState("A001");
  const [pzName, setPzName] = useState("");
  const [pzResultJST, setPzResultJST] = useState(""); // "YYYY-MM-DD HH:MM"
  const [pzMsg, setPzMsg] = useState("");

  const fetchPrize = async () => {
    setPzMsg("");
    if (!pzId) return setPzMsg("賞品IDを入力してください。");
    try {
      const r = await axios.get(`${API_BASE}/api/product/${encodeURIComponent(pzId)}`);
      setPzName(r.data.prizeName || "");
      setPzResultJST(r.data.resultTimeJST || "");
      setPzMsg("読み込み成功。必要なら編集して保存してください。");
    } catch {
      setPzMsg("読み込み失敗。新規作成する場合は名前と公開時刻を入力して保存してください。");
      setPzName("");
      setPzResultJST("");
    }
  };

  const savePrize = async () => {
    setPzMsg("");
    if (!pzId || !pzName) return setPzMsg("賞品IDと名前は必須です。");
    // 簡易バリデーション: "YYYY-MM-DD HH:MM" か空
    if (pzResultJST && !/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/.test(pzResultJST)) {
      return setPzMsg("公開時刻(JST)は YYYY-MM-DD HH:MM 形式で入力してください。例: 2025-08-20 12:00");
    }
    try {
      await axios.post(`${API_BASE}/api/admin/prize/upsert`, {
        id: pzId,
        name: pzName,
        resultTimeJST: pzResultJST || null,
      });
      setPzMsg("保存しました（Upsert）。");
    } catch {
      setPzMsg("保存に失敗しました。");
    }
  };

  // ---------- ③ エントリー一括登録 ----------
  const [enPrizeId, setEnPrizeId] = useState("A001");
  const [csvText, setCsvText] = useState("entryNumber,password,isWinner\n001,1234,true\n002,5678,false");
  const [entriesPreview, setEntriesPreview] = useState([]);
  const [enMsg, setEnMsg] = useState("");

  const parseCSV = () => {
    setEnMsg("");
    const lines = csvText.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
    if (lines.length === 0) {
      setEntriesPreview([]);
      return setEnMsg("CSVが空です。");
    }
    // ヘッダー対応（任意）: entryNumber,password,isWinner
    let start = 0;
    if (/entrynumber/i.test(lines[0]) && /password/i.test(lines[0])) {
      start = 1;
    }
    const out = [];
    for (let i = start; i < lines.length; i++) {
      const cols = lines[i].split(",").map((c) => c.trim());
      if (cols.length < 2) continue;
      const entryNumber = cols[0];
      const password = cols[1];
      const isWinner = (cols[2] || "").toLowerCase() === "true";
      if (!entryNumber || !password) continue;
      out.push({ entryNumber, password, isWinner });
    }
    setEntriesPreview(out);
    if (out.length === 0) setEnMsg("有効な行が見つかりませんでした。");
  };

  const uploadEntries = async () => {
    setEnMsg("");
    if (!enPrizeId) return setEnMsg("賞品IDを入力してください。");
    if (entriesPreview.length === 0) return setEnMsg("先にCSVを解析してください。");
    try {
      const r = await axios.post(`${API_BASE}/api/admin/entries/bulk`, {
        prizeId: enPrizeId,
        entries: entriesPreview,
      });
      setEnMsg(`登録成功：${r.data.count} 件`);
    } catch {
      setEnMsg("登録に失敗しました。");
    }
  };

  return (
    <div style={{ padding: 16, maxWidth: 1100, margin: "0 auto" }}>
      <h1 style={{ margin: "0 0 12px 0" }}>管理画面</h1>

      {/* タブ */}
      <div style={{ display: "flex", gap: 8, marginBottom: 16 }}>
        <button
          onClick={() => setActiveTab("qr")}
          style={{
            padding: "8px 12px",
            borderRadius: 8,
            border: "1px solid #d1d5db",
            background: activeTab === "qr" ? "#e5e7eb" : "white",
            cursor: "pointer",
          }}
        >
          ① QR発行
        </button>
        <button
          onClick={() => setActiveTab("prize")}
          style={{
            padding: "8px 12px",
            borderRadius: 8,
            border: "1px solid #d1d5db",
            background: activeTab === "prize" ? "#e5e7eb" : "white",
            cursor: "pointer",
          }}
        >
          ② 賞品CRUD（作成/更新）
        </button>
        <button
          onClick={() => setActiveTab("entries")}
          style={{
            padding: "8px 12px",
            borderRadius: 8,
            border: "1px solid #d1d5db",
            background: activeTab === "entries" ? "#e5e7eb" : "white",
            cursor: "pointer",
          }}
        >
          ③ エントリー一括登録（CSV）
        </button>
      </div>

      {/* ① QR発行 */}
      {activeTab === "qr" && (
        <Section title="① QR発行（賞品ID → 参加者用URL/QRを生成）">
          <div style={{ display: "grid", gap: 8, marginBottom: 16 }}>
            <label>賞品ID（カンマ区切り例：A001,B002）</label>
            <input
              value={idsInput}
              onChange={(e) => setIdsInput(e.target.value)}
              style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }}
            />
            <button
              onClick={loadInfoForQR}
              disabled={qrLoading || prizeIds.length === 0}
              style={{
                width: 220, padding: "10px 14px", borderRadius: 8,
                border: "1px solid #2563eb", background: "#2563eb", color: "white", fontWeight: 600, cursor: "pointer",
              }}
            >
              {qrLoading ? "読み込み中…" : "確認 & QR生成"}
            </button>
          </div>

          <div style={{ display: "grid", gap: 16, gridTemplateColumns: "repeat(auto-fill, minmax(280px, 1fr))" }}>
            {qrItems.map((it) => {
              const url = buildUrl(it.id);
              return (
                <div key={it.id} style={{ border: "1px solid #e5e7eb", borderRadius: 12, padding: 12 }}>
                  <div style={{ fontWeight: 700, marginBottom: 4 }}>ID: {it.id}</div>
                  {it.ok ? (
                    <>
                      <div style={{ color: "#374151", fontSize: 13, marginBottom: 8 }}>
                        {it.data.prizeName}
                        <br />
                        公開予定（JST）：{it.data.resultTimeJST || "未設定"}
                      </div>
                      <div style={{ background: "white", padding: 8, borderRadius: 8, display: "grid", placeItems: "center" }}>
                        <QRCode id={`qr-${it.id}`} value={url} size={220} />
                      </div>
                      <div style={{ fontSize: 12, marginTop: 8, wordBreak: "break-all" }}>{url}</div>
                      <div style={{ display: "flex", gap: 8, marginTop: 8 }}>
                        <button onClick={() => copyUrl(url)} style={{ padding: "8px 10px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}>
                          URLコピー
                        </button>
                        <button onClick={() => downloadPng(it.id)} style={{ padding: "8px 10px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}>
                          PNG保存
                        </button>
                      </div>
                    </>
                  ) : (
                    <div style={{ color: "crimson" }}>商品情報の取得に失敗しました</div>
                  )}
                </div>
              );
            })}
          </div>
        </Section>
      )}

      {/* ② 賞品CRUD */}
      {activeTab === "prize" && (
        <Section title="② 賞品の作成/更新（Upsert）">
          <div style={{ display: "grid", gap: 10, maxWidth: 520 }}>
            <label>賞品ID（例：A001）</label>
            <input value={pzId} onChange={(e) => setPzId(e.target.value)} style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }} />
            <label>賞品名</label>
            <input value={pzName} onChange={(e) => setPzName(e.target.value)} style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }} />
            <label>公開時刻（JST、例：2025-08-20 12:00）</label>
            <input value={pzResultJST} onChange={(e) => setPzResultJST(e.target.value)} style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }} />
            <div style={{ display: "flex", gap: 8 }}>
              <button onClick={fetchPrize} style={{ padding: "8px 12px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}>読み込み</button>
              <button onClick={savePrize} style={{ padding: "8px 12px", borderRadius: 8, border: "1px solid #2563eb", background: "#2563eb", color: "white", cursor: "pointer" }}>保存（Upsert）</button>
            </div>
            {pzMsg && <div style={{ color: "#111827", background: "#f3f4f6", padding: 8, borderRadius: 8 }}>{pzMsg}</div>}
          </div>
          <div style={{ marginTop: 8, fontSize: 12, color: "#6b7280" }}>
            ※ JST入力は <code>YYYY-MM-DD HH:MM</code> 形式。保存時にサーバー側でUTCに変換されます。
          </div>
        </Section>
      )}

      {/* ③ エントリー一括登録 */}
      {activeTab === "entries" && (
        <Section title="③ エントリー一括登録（CSV貼り付け）">
          <div style={{ display: "grid", gap: 10, maxWidth: 900 }}>
            <label>賞品ID（登録先）</label>
            <input value={enPrizeId} onChange={(e) => setEnPrizeId(e.target.value)} style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db", maxWidth: 520 }} />

            <label>CSV（ヘッダー行可）：<code>entryNumber,password,isWinner</code></label>
            <textarea
              value={csvText}
              onChange={(e) => setCsvText(e.target.value)}
              rows={8}
              style={{ width: "100%", padding: 10, borderRadius: 8, border: "1px solid #d1d5db", fontFamily: "monospace" }}
            />

            <div style={{ display: "flex", gap: 8 }}>
              <button onClick={parseCSV} style={{ padding: "8px 12px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}>CSV解析</button>
              <button onClick={uploadEntries} style={{ padding: "8px 12px", borderRadius: 8, border: "1px solid #2563eb", background: "#2563eb", color: "white", cursor: "pointer" }}>登録</button>
            </div>

            {entriesPreview.length > 0 && (
              <div style={{ overflowX: "auto" }}>
                <table style={{ borderCollapse: "collapse", width: "100%" }}>
                  <thead>
                    <tr>
                      <th style={{ border: "1px solid #e5e7eb", padding: 6 }}>#</th>
                      <th style={{ border: "1px solid #e5e7eb", padding: 6 }}>entryNumber</th>
                      <th style={{ border: "1px solid #e5e7eb", padding: 6 }}>password</th>
                      <th style={{ border: "1px solid #e5e7eb", padding: 6 }}>isWinner</th>
                    </tr>
                  </thead>
                  <tbody>
                    {entriesPreview.map((e, idx) => (
                      <tr key={idx}>
                        <td style={{ border: "1px solid #e5e7eb", padding: 6 }}>{idx + 1}</td>
                        <td style={{ border: "1px solid #e5e7eb", padding: 6 }}>{e.entryNumber}</td>
                        <td style={{ border: "1px solid #e5e7eb", padding: 6 }}>{e.password}</td>
                        <td style={{ border: "1px solid #e5e7eb", padding: 6 }}>{String(e.isWinner)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
                <div style={{ marginTop: 8, fontSize: 13 }}>プレビュー件数：{entriesPreview.length}</div>
              </div>
            )}

            {enMsg && <div style={{ color: "#111827", background: "#f3f4f6", padding: 8, borderRadius: 8 }}>{enMsg}</div>}
          </div>
          <div style={{ marginTop: 8, fontSize: 12, color: "#6b7280" }}>
            ※ 同じ <code>(prize_id, entry_number)</code> は上書き更新されます。
          </div>
        </Section>
      )}
    </div>
  );
}
```

---

# 2) 必要パッケージ（未導入なら）
```bash
cd "/Users/m-aoki/Downloads/comiket-lottery-app/frontend"
npm install axios react-qr-code
```

> `.env` は今のままでOK（APIは `REACT_APP_API_BASE=http://localhost:3001`）。

---

# 3) 起動・確認
```bash
# バックエンド（DB対応済み）
cd "/Users/m-aoki/Downloads/comiket-lottery-app/backend"
PORT=3001 node index.js

# フロント
cd "/Users/m-aoki/Downloads/comiket-lottery-app/frontend"
npm start
```

- 管理画面：`http://localhost:3000/admin`
  - **①QR発行**：`A001,B002` → 「確認&QR生成」→ QR表示/URLコピー/PNG保存
  - **②賞品CRUD**：IDで「読み込み」→ 編集→「保存（Upsert）」
  - **③エントリー一括登録**：CSV貼り付け→「CSV解析」→「登録」
- 参加者：`http://localhost:3000/?prizeId=A001`

---

## よくあるハマり
- 「保存（Upsert）」で403など → バックエンドが起動しているか、`API_BASE` のURLを再確認  
- CSVの `isWinner` は `true/false` 小文字でOK（空・未指定は false 扱い）  
- 公開前にフォームが出ない → `result_time_jst` を現在より**過去**にするか、一時的に `FORCE_PUBLISH_ALL=1` でAPI起動

---

この管理GUIで、**運営がブラウザだけでデータ投入・更新・QR配布**まで完結できます。  
次は「CSVアップロード（ファイル選択対応）」や「管理ログイン」も追加できますが、まずはここまで動作確認してください。

---

user:
賞品CRUDって分かりづらい

---

system:


---

system:


---

assistant:
わかる！「CRUD」ってエンジニア用語で分かりづらいですよね。  
UIを**ぜんぶ日本語の意味ベース**に直します。

- 「賞品CRUD」 → **「賞品の登録・編集」**
- 「エントリー一括登録」 → **「参加者リスト登録（CSV）」**
- ボタン文言も「保存（Upsert）」→ **「保存する」**、などに変更

下の手順どおり**丸ごと上書き**してください。

---

## 置き換え（丸ごと）：`/Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/Admin.jsx`

```jsx
// /Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/Admin.jsx
import React, { useMemo, useState } from "react";
import axios from "axios";
import QRCode from "react-qr-code";

const API_BASE = process.env.REACT_APP_API_BASE || "http://localhost:3001";
const FRONT_BASE = process.env.REACT_APP_FRONT_BASE || "http://localhost:3000";

function Section({ title, subtitle, children }) {
  return (
    <section style={{ border: "1px solid #e5e7eb", borderRadius: 12, padding: 16, marginBottom: 16 }}>
      <h2 style={{ margin: "0 0 6px 0", fontSize: 18 }}>{title}</h2>
      {subtitle && <div style={{ color: "#6b7280", fontSize: 13, marginBottom: 10 }}>{subtitle}</div>}
      {children}
    </section>
  );
}

export default function Admin() {
  const [activeTab, setActiveTab] = useState("qr"); // 'qr' | 'prize' | 'entries'

  // ---------- ① QR配布 ----------
  const [idsInput, setIdsInput] = useState("A001");
  const prizeIds = useMemo(
    () => idsInput.split(",").map((s) => s.trim()).filter(Boolean),
    [idsInput]
  );
  const [qrItems, setQrItems] = useState([]);
  const [qrLoading, setQrLoading] = useState(false);

  const buildUrl = (id) => `${FRONT_BASE}/?prizeId=${encodeURIComponent(id)}`;

  const loadInfoForQR = async () => {
    setQrLoading(true);
    const result = [];
    for (const id of prizeIds) {
      try {
        const res = await axios.get(`${API_BASE}/api/product/${encodeURIComponent(id)}`);
        result.push({ id, ok: true, data: res.data });
      } catch {
        result.push({ id, ok: false, error: "取得失敗" });
      }
    }
    setQrItems(result);
    setQrLoading(false);
  };

  const copyUrl = async (url) => {
    try {
      await navigator.clipboard.writeText(url);
      alert("URLをコピーしました");
    } catch {
      alert("コピーに失敗しました");
    }
  };

  const downloadPng = (id) => {
    const svg = document.getElementById(`qr-${id}`);
    if (!svg) return;
    const xml = new XMLSerializer().serializeToString(svg);
    const svg64 = window.btoa(unescape(encodeURIComponent(xml)));
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      const size = 512;
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, size, size);
      ctx.drawImage(img, 0, 0, size, size);
      const link = document.createElement("a");
      link.download = `qr-${id}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    };
    img.src = "data:image/svg+xml;base64," + svg64;
  };

  // ---------- ② 賞品の登録・編集 ----------
  const [pzId, setPzId] = useState("A001");
  const [pzName, setPzName] = useState("");
  const [pzResultJST, setPzResultJST] = useState(""); // "YYYY-MM-DD HH:MM"
  const [pzMsg, setPzMsg] = useState("");

  const fetchPrize = async () => {
    setPzMsg("");
    if (!pzId) return setPzMsg("賞品IDを入力してください。");
    try {
      const r = await axios.get(`${API_BASE}/api/product/${encodeURIComponent(pzId)}`);
      setPzName(r.data.prizeName || "");
      setPzResultJST(r.data.resultTimeJST || "");
      setPzMsg("読み込み成功。内容を編集して「保存する」を押してください。");
    } catch {
      setPzMsg("読み込みに失敗しました。新規作成する場合は名前と公開時刻を入力して「保存する」を押してください。");
      setPzName("");
      setPzResultJST("");
    }
  };

  const savePrize = async () => {
    setPzMsg("");
    if (!pzId || !pzName) return setPzMsg("賞品IDと名前は必須です。");
    // "YYYY-MM-DD HH:MM" か空
    if (pzResultJST && !/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/.test(pzResultJST)) {
      return setPzMsg("公開時刻（JST）は 例）2025-08-20 12:00 の形式で入力してください。");
    }
    try {
      await axios.post(`${API_BASE}/api/admin/prize/upsert`, {
        id: pzId,
        name: pzName,
        resultTimeJST: pzResultJST || null,
      });
      setPzMsg("保存しました。");
    } catch {
      setPzMsg("保存に失敗しました。");
    }
  };

  // ---------- ③ 参加者リスト登録（CSV） ----------
  const [enPrizeId, setEnPrizeId] = useState("A001");
  const [csvText, setCsvText] = useState("entryNumber,password,isWinner\n001,1234,true\n002,5678,false");
  const [entriesPreview, setEntriesPreview] = useState([]);
  const [enMsg, setEnMsg] = useState("");

  const parseCSV = () => {
    setEnMsg("");
    const lines = csvText.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
    if (lines.length === 0) {
      setEntriesPreview([]);
      return setEnMsg("CSVが空です。");
    }
    // 先頭行がヘッダーならスキップ
    let start = 0;
    if (/entrynumber/i.test(lines[0]) && /password/i.test(lines[0])) start = 1;

    const out = [];
    for (let i = start; i < lines.length; i++) {
      const cols = lines[i].split(",").map((c) => c.trim());
      if (cols.length < 2) continue;
      const entryNumber = cols[0];
      const password = cols[1];
      const isWinner = (cols[2] || "").toLowerCase() === "true";
      if (!entryNumber || !password) continue;
      out.push({ entryNumber, password, isWinner });
    }
    setEntriesPreview(out);
    if (out.length === 0) setEnMsg("有効な行が見つかりませんでした。");
  };

  const uploadEntries = async () => {
    setEnMsg("");
    if (!enPrizeId) return setEnMsg("賞品IDを入力してください。");
    if (entriesPreview.length === 0) return setEnMsg("先にCSVを解析してください。");
    try {
      const r = await axios.post(`${API_BASE}/api/admin/entries/bulk`, {
        prizeId: enPrizeId,
        entries: entriesPreview,
      });
      setEnMsg(`登録に成功しました：${r.data.count} 件`);
    } catch {
      setEnMsg("登録に失敗しました。");
    }
  };

  return (
    <div style={{ padding: 16, maxWidth: 1100, margin: "0 auto" }}>
      <h1 style={{ margin: "0 0 12px 0" }}>管理画面</h1>

      {/* タブ */}
      <div style={{ display: "flex", gap: 8, marginBottom: 16 }}>
        <button
          onClick={() => setActiveTab("qr")}
          style={{
            padding: "8px 12px", borderRadius: 8, border: "1px solid #d1d5db",
            background: activeTab === "qr" ? "#e5e7eb" : "white", cursor: "pointer",
          }}
        >
          ① QR配布
        </button>
        <button
          onClick={() => setActiveTab("prize")}
          style={{
            padding: "8px 12px", borderRadius: 8, border: "1px solid #d1d5db",
            background: activeTab === "prize" ? "#e5e7eb" : "white", cursor: "pointer",
          }}
        >
          ② 賞品の登録・編集
        </button>
        <button
          onClick={() => setActiveTab("entries")}
          style={{
            padding: "8px 12px", borderRadius: 8, border: "1px solid #d1d5db",
            background: activeTab === "entries" ? "#e5e7eb" : "white", cursor: "pointer",
          }}
        >
          ③ 参加者リスト登録（CSV）
        </button>
      </div>

      {/* ① QR配布 */}
      {activeTab === "qr" && (
        <Section
          title="① QR配布（賞品IDから参加者用QRとURLを作る）"
          subtitle="賞品IDをカンマ区切りで入力してください。例：A001,B002"
        >
          <div style={{ display: "grid", gap: 8, marginBottom: 16 }}>
            <label>賞品ID</label>
            <input
              value={idsInput}
              onChange={(e) => setIdsInput(e.target.value)}
              style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }}
            />
            <button
              onClick={loadInfoForQR}
              disabled={qrLoading || prizeIds.length === 0}
              style={{
                width: 220, padding: "10px 14px", borderRadius: 8,
                border: "1px solid #2563eb", background: "#2563eb", color: "white", fontWeight: 600, cursor: "pointer",
              }}
            >
              {qrLoading ? "読み込み中…" : "確認 & QR生成"}
            </button>
          </div>

          <div style={{ display: "grid", gap: 16, gridTemplateColumns: "repeat(auto-fill, minmax(280px, 1fr))" }}>
            {qrItems.map((it) => {
              const url = buildUrl(it.id);
              return (
                <div key={it.id} style={{ border: "1px solid #e5e7eb", borderRadius: 12, padding: 12 }}>
                  <div style={{ fontWeight: 700, marginBottom: 4 }}>ID: {it.id}</div>
                  {it.ok ? (
                    <>
                      <div style={{ color: "#374151", fontSize: 13, marginBottom: 8 }}>
                        {it.data.prizeName}
                        <br />
                        公開予定（JST）：{it.data.resultTimeJST || "未設定"}
                      </div>
                      <div style={{ background: "white", padding: 8, borderRadius: 8, display: "grid", placeItems: "center" }}>
                        <QRCode id={`qr-${it.id}`} value={url} size={220} />
                      </div>
                      <div style={{ fontSize: 12, marginTop: 8, wordBreak: "break-all" }}>{url}</div>
                      <div style={{ display: "flex", gap: 8, marginTop: 8 }}>
                        <button onClick={() => copyUrl(url)} style={{ padding: "8px 10px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}>
                          URLコピー
                        </button>
                        <button onClick={() => downloadPng(it.id)} style={{ padding: "8px 10px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}>
                          PNG保存
                        </button>
                      </div>
                    </>
                  ) : (
                    <div style={{ color: "crimson" }}>商品情報の取得に失敗しました</div>
                  )}
                </div>
              );
            })}
          </div>
        </Section>
      )}

      {/* ② 賞品の登録・編集 */}
      {activeTab === "prize" && (
        <Section
          title="② 賞品の登録・編集"
          subtitle="公開時刻（JST）を設定すると、参加者側はその時刻までは結果を見られません。"
        >
          <div style={{ display: "grid", gap: 10, maxWidth: 520 }}>
            <label>賞品ID（例：A001）</label>
            <input value={pzId} onChange={(e) => setPzId(e.target.value)} style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }} />
            <label>賞品名</label>
            <input value={pzName} onChange={(e) => setPzName(e.target.value)} style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }} />
            <label>公開時刻（JST、例：2025-08-20 12:00）</label>
            <input value={pzResultJST} onChange={(e) => setPzResultJST(e.target.value)} style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }} />
            <div style={{ display: "flex", gap: 8 }}>
              <button onClick={fetchPrize} style={{ padding: "8px 12px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}>賞品を読み込む</button>
              <button onClick={savePrize} style={{ padding: "8px 12px", borderRadius: 8, border: "1px solid #2563eb", background: "#2563eb", color: "white", cursor: "pointer" }}>保存する</button>
            </div>
            {pzMsg && <div style={{ color: "#111827", background: "#f3f4f6", padding: 8, borderRadius: 8 }}>{pzMsg}</div>}
          </div>
          <div style={{ marginTop: 8, fontSize: 12, color: "#6b7280" }}>
            ※ JSTの形式は <code>YYYY-MM-DD HH:MM</code>。保存時にサーバー側でUTCへ変換されます。
          </div>
        </Section>
      )}

      {/* ③ 参加者リスト登録（CSV） */}
      {activeTab === "entries" && (
        <Section
          title="③ 参加者リスト登録（CSV）"
          subtitle="列は entryNumber,password,isWinner（true/false）。同じ（賞品ID, 抽選番号）は上書きします。"
        >
          <div style={{ display: "grid", gap: 10, maxWidth: 900 }}>
            <label>賞品ID（登録先）</label>
            <input value={enPrizeId} onChange={(e) => setEnPrizeId(e.target.value)} style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db", maxWidth: 520 }} />

            <label>CSV（ヘッダー行可）</label>
            <textarea
              value={csvText}
              onChange={(e) => setCsvText(e.target.value)}
              rows={8}
              style={{ width: "100%", padding: 10, borderRadius: 8, border: "1px solid #d1d5db", fontFamily: "monospace" }}
            />

            <div style={{ display: "flex", gap: 8 }}>
              <button onClick={parseCSV} style={{ padding: "8px 12px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}>CSVを解析</button>
              <button onClick={uploadEntries} style={{ padding: "8px 12px", borderRadius: 8, border: "1px solid #2563eb", background: "#2563eb", color: "white", cursor: "pointer" }}>登録する</button>
            </div>

            {entriesPreview.length > 0 && (
              <div style={{ overflowX: "auto" }}>
                <table style={{ borderCollapse: "collapse", width: "100%" }}>
                  <thead>
                    <tr>
                      <th style={{ border: "1px solid #e5e7eb", padding: 6 }}>#</th>
                      <th style={{ border: "1px solid #e5e7eb", padding: 6 }}>抽選番号 (entryNumber)</th>
                      <th style={{ border: "1px solid #e5e7eb", padding: 6 }}>パスワード (password)</th>
                      <th style={{ border: "1px solid #e5e7eb", padding: 6 }}>当選 (isWinner)</th>
                    </tr>
                  </thead>
                  <tbody>
                    {entriesPreview.map((e, idx) => (
                      <tr key={idx}>
                        <td style={{ border: "1px solid #e5e7eb", padding: 6 }}>{idx + 1}</td>
                        <td style={{ border: "1px solid #e5e7eb", padding: 6 }}>{e.entryNumber}</td>
                        <td style={{ border: "1px solid #e5e7eb", padding: 6 }}>{e.password}</td>
                        <td style={{ border: "1px solid #e5e7eb", padding: 6 }}>{String(e.isWinner)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
                <div style={{ marginTop: 8, fontSize: 13 }}>プレビュー件数：{entriesPreview.length}</div>
              </div>
            )}

            {enMsg && <div style={{ color: "#111827", background: "#f3f4f6", padding: 8, borderRadius: 8 }}>{enMsg}</div>}
          </div>
        </Section>
      )}
    </div>
  );
}
```

---

### 説明（用語を平易化）
- **登録・編集**＝「新しく作る／直す」（Create/Update）  
- **削除**は今はGUI未搭載（要望があれば追加します）  
- **参加者リスト登録（CSV）**＝「当選/落選を含むエントリーの一括投入」

---

必要なら、**削除（賞品・参加者）ボタン**や、**CSVのファイルアップロード**にも対応できます。  
まずはこの日本語UIで使い勝手を見て、次に「削除ボタン」追加や「検索・並び替え」に進みましょう。

---

user:
説明（用語を平易化）、削除GUI追加、「当選/落選を含むエントリーの一括投入」、削除（賞品・参加者）ボタンや、CSVのファイルアップロード、ORコードのPNG保存にIDと公開予定とURLの記入

---

system:


---

system:


---

assistant:
了解！ご要望を全部まとめて反映します。  
（**丸ごと上書き**と**追記**を明示します。コピペ通りでOK）

---

# まず用語の平易な説明（画面にも反映）

- **賞品の登録・編集** … 「賞品を新しく作る／名前や公開時刻を直す」
- **公開時刻（JST）** … 参加者が結果を見られるようになる時刻（日本時間）
- **参加者リスト登録（CSV）** … 「抽選番号・パスワード・当選/落選」をまとめて入れる
- **削除** … 賞品や参加者データを消す（※削除は取り戻せません）
- **QR配布** … 参加者がアクセスするURLとQRを用意して配る  
- **QRのPNG保存（注釈入り）** … 画像に「賞品ID／公開予定／URL」を文字で入れて保存

---

# 1) バックエンドAPIを拡張

## 1-1) `backend/index.js` に**追記**（削除API、一覧API）
以下を **既存の `app.post("/api/admin/entries/bulk"...` の下あたり**に**追記**してください。

```js
// ====== 管理用 追加API（削除・一覧） ======

// 賞品を削除（関連エントリーも cascade で削除）
app.post("/api/admin/prize/delete", async (req, res) => {
  try {
    const { id } = req.body || {};
    if (!id) return res.status(400).json({ error: "missing_id" });
    await pool.query(`delete from prizes where id=$1`, [id]);
    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "server_error" });
  }
});

// 参加者（エントリー）を1件削除
app.post("/api/admin/entry/delete", async (req, res) => {
  try {
    const { prizeId, entryNumber } = req.body || {};
    if (!prizeId || !entryNumber) return res.status(400).json({ error: "missing_fields" });
    await pool.query(`delete from entries where prize_id=$1 and entry_number=$2`, [prizeId, entryNumber]);
    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "server_error" });
  }
});

// 指定賞品の参加者一覧（簡易）
app.get("/api/admin/entries/:prizeId", async (req, res) => {
  try {
    const { prizeId } = req.params;
    const { rows } = await pool.query(
      `select entry_number as "entryNumber", password, is_winner as "isWinner"
         from entries
        where prize_id=$1
        order by entry_number asc`,
      [prizeId]
    );
    res.json({ prizeId, entries: rows });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "server_error" });
  }
});
```

> 補足：`prizes` は `entries` に外部キー `on delete cascade` なので、賞品削除で紐づく参加者も消えます。

---

# 2) フロント管理画面を拡張（削除、CSVファイル、QR PNG注釈）

## 2-1) `frontend/src/Admin.jsx` を**丸ごと上書き**

```jsx
// /Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/Admin.jsx
import React, { useMemo, useRef, useState } from "react";
import axios from "axios";
import QRCode from "react-qr-code";

const API_BASE = process.env.REACT_APP_API_BASE || "http://localhost:3001";
const FRONT_BASE = process.env.REACT_APP_FRONT_BASE || "http://localhost:3000";

function Section({ title, subtitle, children }) {
  return (
    <section style={{ border: "1px solid #e5e7eb", borderRadius: 12, padding: 16, marginBottom: 16 }}>
      <h2 style={{ margin: "0 0 6px 0", fontSize: 18 }}>{title}</h2>
      {subtitle && <div style={{ color: "#6b7280", fontSize: 13, marginBottom: 10 }}>{subtitle}</div>}
      {children}
    </section>
  );
}

export default function Admin() {
  const [activeTab, setActiveTab] = useState("qr"); // 'qr' | 'prize' | 'entries'

  // ==================== ① QR配布 ====================
  const [idsInput, setIdsInput] = useState("A001");
  const prizeIds = useMemo(
    () => idsInput.split(",").map((s) => s.trim()).filter(Boolean),
    [idsInput]
  );
  const [qrItems, setQrItems] = useState([]);
  const [qrLoading, setQrLoading] = useState(false);

  const buildUrl = (id) => `${FRONT_BASE}/?prizeId=${encodeURIComponent(id)}`;

  const loadInfoForQR = async () => {
    setQrLoading(true);
    const result = [];
    for (const id of prizeIds) {
      try {
        const res = await axios.get(`${API_BASE}/api/product/${encodeURIComponent(id)}`);
        result.push({ id, ok: true, data: res.data });
      } catch {
        result.push({ id, ok: false, error: "取得失敗" });
      }
    }
    setQrItems(result);
    setQrLoading(false);
  };

  const copyUrl = async (url) => {
    try {
      await navigator.clipboard.writeText(url);
      alert("URLをコピーしました");
    } catch {
      alert("コピーに失敗しました");
    }
  };

  // QR PNGに注釈（ID・公開予定・URL）を焼き込んで保存
  const downloadPngAnnotated = (item) => {
    const { id, data } = item;
    const svg = document.getElementById(`qr-${id}`);
    if (!svg) return;
    const xml = new XMLSerializer().serializeToString(svg);
    const svg64 = window.btoa(unescape(encodeURIComponent(xml)));
    const img = new Image();
    img.onload = () => {
      const QR_SIZE = 660; // QR描画領域
      const W = 660;       // 画像幅
      const PAD = 24;
      // 注釈の行：ID、公開予定、URL → 3行想定
      const TEXT_H = 18;
      const LINES = [
        `ID: ${id}`,
        `公開予定(JST): ${data?.resultTimeJST || "未設定"}`,
        `URL: ${buildUrl(id)}`
      ];
      const INFO_H = PAD + LINES.length * (TEXT_H + 6) + PAD;
      const H = QR_SIZE + INFO_H;

      const canvas = document.createElement("canvas");
      canvas.width = W;
      canvas.height = H;
      const ctx = canvas.getContext("2d");
      // 背景
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, W, H);
      // QRを上部に描画（マージン）
      ctx.drawImage(img, (W - QR_SIZE) / 2, PAD, QR_SIZE, QR_SIZE);

      // 罫線
      ctx.strokeStyle = "#e5e7eb";
      ctx.strokeRect(0.5, 0.5, W - 1, H - 1);

      // 注釈
      ctx.fillStyle = "#111827";
      ctx.font = "16px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif";
      let y = QR_SIZE + PAD + 18;
      for (const line of LINES) {
        // 長いURLの折り返し: 適当に300pxで切る
        const maxWidth = W - PAD * 2;
        const words = line.split(" ");
        let tmp = "";
        for (const w of words) {
          const test = tmp ? tmp + " " + w : w;
          if (ctx.measureText(test).width > maxWidth) {
            ctx.fillText(tmp, PAD, y);
            y += TEXT_H + 6;
            tmp = w;
          } else {
            tmp = test;
          }
        }
        if (tmp) {
          ctx.fillText(tmp, PAD, y);
          y += TEXT_H + 6;
        }
      }

      const link = document.createElement("a");
      link.download = `qr-${id}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    };
    img.src = "data:image/svg+xml;base64," + svg64;
  };

  // ==================== ② 賞品の登録・編集 + 削除 ====================
  const [pzId, setPzId] = useState("A001");
  const [pzName, setPzName] = useState("");
  const [pzResultJST, setPzResultJST] = useState(""); // "YYYY-MM-DD HH:MM"
  const [pzMsg, setPzMsg] = useState("");

  const fetchPrize = async () => {
    setPzMsg("");
    if (!pzId) return setPzMsg("賞品IDを入力してください。");
    try {
      const r = await axios.get(`${API_BASE}/api/product/${encodeURIComponent(pzId)}`);
      setPzName(r.data.prizeName || "");
      setPzResultJST(r.data.resultTimeJST || "");
      setPzMsg("読み込み成功。内容を編集して「保存する」を押してください。");
    } catch {
      setPzMsg("読み込みに失敗しました。新規作成する場合は名前と公開時刻を入力して「保存する」を押してください。");
      setPzName("");
      setPzResultJST("");
    }
  };

  const savePrize = async () => {
    setPzMsg("");
    if (!pzId || !pzName) return setPzMsg("賞品IDと名前は必須です。");
    if (pzResultJST && !/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/.test(pzResultJST)) {
      return setPzMsg("公開時刻（JST）は 例）2025-08-20 12:00 の形式で入力してください。");
    }
    try {
      await axios.post(`${API_BASE}/api/admin/prize/upsert`, {
        id: pzId,
        name: pzName,
        resultTimeJST: pzResultJST || null,
      });
      setPzMsg("保存しました。");
    } catch {
      setPzMsg("保存に失敗しました。");
    }
  };

  const deletePrize = async () => {
    if (!pzId) return setPzMsg("賞品IDを入力してください。");
    if (!window.confirm(`賞品「${pzId}」を削除します。関連する参加者データも削除されます。よろしいですか？`)) return;
    try {
      await axios.post(`${API_BASE}/api/admin/prize/delete`, { id: pzId });
      setPzName("");
      setPzResultJST("");
      setPzMsg("削除しました。");
    } catch {
      setPzMsg("削除に失敗しました。");
    }
  };

  // ==================== ③ 参加者リスト登録（CSV） + 一覧 + 削除 ====================
  const [enPrizeId, setEnPrizeId] = useState("A001");
  const [csvText, setCsvText] = useState("entryNumber,password,isWinner\n001,1234,true\n002,5678,false");
  const [entriesPreview, setEntriesPreview] = useState([]);
  const [enMsg, setEnMsg] = useState("");
  const fileRef = useRef(null);
  const [remoteEntries, setRemoteEntries] = useState([]);

  // CSVテキスト解析（ヘッダー可）
  const parseCSVText = (text) => {
    const lines = text.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
    if (lines.length === 0) return [];
    let start = 0;
    if (/entrynumber/i.test(lines[0]) && /password/i.test(lines[0])) start = 1;
    const out = [];
    for (let i = start; i < lines.length; i++) {
      const cols = lines[i].split(",").map((c) => c.trim());
      if (cols.length < 2) continue;
      const entryNumber = cols[0];
      const password = cols[1];
      const isWinner = (cols[2] || "").toLowerCase() === "true";
      if (!entryNumber || !password) continue;
      out.push({ entryNumber, password, isWinner });
    }
    return out;
  };

  const parseCSV = () => {
    setEnMsg("");
    const out = parseCSVText(csvText);
    setEntriesPreview(out);
    if (out.length === 0) setEnMsg("有効な行が見つかりませんでした。");
  };

  // CSVファイルを読み込んでtextareaに入れる
  const onSelectCSV = async (e) => {
    setEnMsg("");
    const f = e.target.files?.[0];
    if (!f) return;
    const text = await f.text();
    setCsvText(text);
    const out = parseCSVText(text);
    setEntriesPreview(out);
    if (out.length === 0) setEnMsg("有効な行が見つかりませんでした。");
  };

  // 登録（Upsert）
  const uploadEntries = async () => {
    setEnMsg("");
    if (!enPrizeId) return setEnMsg("賞品IDを入力してください。");
    if (entriesPreview.length === 0) return setEnMsg("先にCSVを解析してください。");
    try {
      const r = await axios.post(`${API_BASE}/api/admin/entries/bulk`, {
        prizeId: enPrizeId,
        entries: entriesPreview,
      });
      setEnMsg(`登録に成功しました：${r.data.count} 件`);
      await fetchRemoteEntries(); // 一覧を更新
    } catch {
      setEnMsg("登録に失敗しました。");
    }
  };

  // 一覧取得
  const fetchRemoteEntries = async () => {
    setEnMsg("");
    if (!enPrizeId) return setEnMsg("賞品IDを入力してください。");
    try {
      const r = await axios.get(`${API_BASE}/api/admin/entries/${encodeURIComponent(enPrizeId)}`);
      setRemoteEntries(r.data.entries || []);
      if (!r.data.entries?.length) setEnMsg("登録済みの参加者はありません。");
    } catch {
      setEnMsg("一覧の取得に失敗しました。");
    }
  };

  // 1件削除
  const deleteEntry = async (entryNumber) => {
    if (!window.confirm(`抽選番号 ${entryNumber} を削除します。よろしいですか？`)) return;
    try {
      await axios.post(`${API_BASE}/api/admin/entry/delete`, {
        prizeId: enPrizeId,
        entryNumber,
      });
      await fetchRemoteEntries();
    } catch {
      alert("削除に失敗しました。");
    }
  };

  return (
    <div style={{ padding: 16, maxWidth: 1100, margin: "0 auto" }}>
      <h1 style={{ margin: "0 0 12px 0" }}>管理画面</h1>

      {/* タブ */}
      <div style={{ display: "flex", gap: 8, marginBottom: 16 }}>
        <button
          onClick={() => setActiveTab("qr")}
          style={{
            padding: "8px 12px", borderRadius: 8, border: "1px solid #d1d5db",
            background: activeTab === "qr" ? "#e5e7eb" : "white", cursor: "pointer",
          }}
        >
          ① QR配布
        </button>
        <button
          onClick={() => setActiveTab("prize")}
          style={{
            padding: "8px 12px", borderRadius: 8, border: "1px solid #d1d5db",
            background: activeTab === "prize" ? "#e5e7eb" : "white", cursor: "pointer",
          }}
        >
          ② 賞品の登録・編集（削除あり）
        </button>
        <button
          onClick={() => setActiveTab("entries")}
          style={{
            padding: "8px 12px", borderRadius: 8, border: "1px solid #d1d5db",
            background: activeTab === "entries" ? "#e5e7eb" : "white", cursor: "pointer",
          }}
        >
          ③ 参加者リスト登録（CSV／一覧・削除）
        </button>
      </div>

      {/* ① QR配布 */}
      {activeTab === "qr" && (
        <Section
          title="① QR配布（賞品IDから参加者用QRとURLを作る）"
          subtitle="賞品IDをカンマ区切りで入力してください。例：A001,B002"
        >
          <div style={{ display: "grid", gap: 8, marginBottom: 16 }}>
            <label>賞品ID</label>
            <input
              value={idsInput}
              onChange={(e) => setIdsInput(e.target.value)}
              style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }}
            />
            <button
              onClick={loadInfoForQR}
              disabled={qrLoading || prizeIds.length === 0}
              style={{
                width: 220, padding: "10px 14px", borderRadius: 8,
                border: "1px solid #2563eb", background: "#2563eb", color: "white", fontWeight: 600, cursor: "pointer",
              }}
            >
              {qrLoading ? "読み込み中…" : "確認 & QR生成"}
            </button>
          </div>

          <div style={{ display: "grid", gap: 16, gridTemplateColumns: "repeat(auto-fill, minmax(320px, 1fr))" }}>
            {qrItems.map((it) => {
              const url = buildUrl(it.id);
              return (
                <div key={it.id} style={{ border: "1px solid #e5e7eb", borderRadius: 12, padding: 12 }}>
                  <div style={{ fontWeight: 700, marginBottom: 4 }}>ID: {it.id}</div>
                  {it.ok ? (
                    <>
                      <div style={{ color: "#374151", fontSize: 13, marginBottom: 8 }}>
                        {it.data.prizeName}
                        <br />
                        公開予定（JST）：{it.data.resultTimeJST || "未設定"}
                      </div>
                      <div style={{ background: "white", padding: 8, borderRadius: 8, display: "grid", placeItems: "center" }}>
                        <QRCode id={`qr-${it.id}`} value={url} size={260} />
                      </div>
                      <div style={{ fontSize: 12, marginTop: 8, wordBreak: "break-all" }}>{url}</div>
                      <div style={{ display: "flex", flexWrap: "wrap", gap: 8, marginTop: 8 }}>
                        <button onClick={() => copyUrl(url)} style={{ padding: "8px 10px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}>
                          URLコピー
                        </button>
                        <button onClick={() => downloadPngAnnotated(it)} style={{ padding: "8px 10px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}>
                          PNG保存（注釈入り）
                        </button>
                      </div>
                    </>
                  ) : (
                    <div style={{ color: "crimson" }}>商品情報の取得に失敗しました</div>
                  )}
                </div>
              );
            })}
          </div>
        </Section>
      )}

      {/* ② 賞品の登録・編集（削除あり） */}
      {activeTab === "prize" && (
        <Section
          title="② 賞品の登録・編集（削除あり）"
          subtitle="公開時刻（JST）を設定すると、参加者はその時刻までは結果を見られません。"
        >
          <div style={{ display: "grid", gap: 10, maxWidth: 520 }}>
            <label>賞品ID（例：A001）</label>
            <input value={pzId} onChange={(e) => setPzId(e.target.value)} style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }} />
            <label>賞品名</label>
            <input value={pzName} onChange={(e) => setPzName(e.target.value)} style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }} />
            <label>公開時刻（JST、例：2025-08-20 12:00）</label>
            <input value={pzResultJST} onChange={(e) => setPzResultJST(e.target.value)} style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }} />
            <div style={{ display: "flex", gap: 8, flexWrap: "wrap" }}>
              <button onClick={fetchPrize} style={{ padding: "8px 12px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}>賞品を読み込む</button>
              <button onClick={savePrize} style={{ padding: "8px 12px", borderRadius: 8, border: "1px solid #2563eb", background: "#2563eb", color: "white", cursor: "pointer" }}>保存する</button>
              <button onClick={deletePrize} style={{ padding: "8px 12px", borderRadius: 8, border: "1px solid #ef4444", background: "white", color: "#ef4444", cursor: "pointer" }}>賞品を削除</button>
            </div>
            {pzMsg && <div style={{ color: "#111827", background: "#f3f4f6", padding: 8, borderRadius: 8 }}>{pzMsg}</div>}
          </div>
          <div style={{ marginTop: 8, fontSize: 12, color: "#6b7280" }}>
            ※ 賞品を削除すると紐づく参加者データも消えます（取り戻せません）。
          </div>
        </Section>
      )}

      {/* ③ 参加者リスト登録（CSV／一覧・削除） */}
      {activeTab === "entries" && (
        <Section
          title="③ 参加者リスト登録（CSV）／一覧・削除"
          subtitle="列は entryNumber,password,isWinner。true/false で当選/落選。"
        >
          <div style={{ display: "grid", gap: 10, maxWidth: 900 }}>
            <label>賞品ID（登録先／一覧対象）</label>
            <input value={enPrizeId} onChange={(e) => setEnPrizeId(e.target.value)} style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db", maxWidth: 520 }} />

            <label>CSVファイルを選択（ヘッダー行可）</label>
            <input type="file" accept=".csv,text/csv" ref={fileRef} onChange={onSelectCSV} />

            <label>CSV（貼り付けも可能）</label>
            <textarea
              value={csvText}
              onChange={(e) => setCsvText(e.target.value)}
              rows={8}
              style={{ width: "100%", padding: 10, borderRadius: 8, border: "1px solid #d1d5db", fontFamily: "monospace" }}
            />

            <div style={{ display: "flex", gap: 8, flexWrap: "wrap" }}>
              <button onClick={parseCSV} style={{ padding: "8px 12px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}>CSVを解析</button>
              <button onClick={uploadEntries} style={{ padding: "8px 12px", borderRadius: 8, border: "1px solid #2563eb", background: "#2563eb", color: "white", cursor: "pointer" }}>登録する</button>
              <button onClick={fetchRemoteEntries} style={{ padding: "8px 12px", borderRadius: 8, border: "1px solid #d1d5db", cursor: "pointer" }}>登録済み一覧を取得</button>
            </div>

            {entriesPreview.length > 0 && (
              <>
                <div style={{ marginTop: 6, fontWeight: 700 }}>登録プレビュー</div>
                <div style={{ overflowX: "auto" }}>
                  <table style={{ borderCollapse: "collapse", width: "100%" }}>
                    <thead>
                      <tr>
                        <th style={{ border: "1px solid #e5e7eb", padding: 6 }}>#</th>
                        <th style={{ border: "1px solid #e5e7eb", padding: 6 }}>抽選番号</th>
                        <th style={{ border: "1px solid #e5e7eb", padding: 6 }}>パスワード</th>
                        <th style={{ border: "1px solid #e5e7eb", padding: 6 }}>当選</th>
                      </tr>
                    </thead>
                    <tbody>
                      {entriesPreview.map((e, idx) => (
                        <tr key={idx}>
                          <td style={{ border: "1px solid #e5e7eb", padding: 6 }}>{idx + 1}</td>
                          <td style={{ border: "1px solid #e5e7eb", padding: 6 }}>{e.entryNumber}</td>
                          <td style={{ border: "1px solid #e5e7eb", padding: 6 }}>{e.password}</td>
                          <td style={{ border: "1px solid #e5e7eb", padding: 6 }}>{String(e.isWinner)}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                <div style={{ marginTop: 8, fontSize: 13 }}>プレビュー件数：{entriesPreview.length}</div>
              </>
            )}

            {remoteEntries.length > 0 && (
              <>
                <div style={{ marginTop: 16, fontWeight: 700 }}>登録済み一覧</div>
                <div style={{ overflowX: "auto" }}>
                  <table style={{ borderCollapse: "collapse", width: "100%" }}>
                    <thead>
                      <tr>
                        <th style={{ border: "1px solid #e5e7eb", padding: 6 }}>抽選番号</th>
                        <th style={{ border: "1px solid #e5e7eb", padding: 6 }}>パスワード</th>
                        <th style={{ border: "1px solid #e5e7

---

user:
追記じゃなくて、全て置き換え出来るようにファイル作って

---

system:


---

system:


---

assistant:
了解！“追記”じゃなく**全部を置き換え**できるように、必要ファイルを一式用意しました。  
下のとおり**ファイルごと丸ごとコピペ**してください（パスも明示）。既存ファイルは上書きでOKです。

---

# ✅ バックエンド一式（DB対応・CRUD・CSV管理・削除API・CORS）

## 1) `/Users/m-aoki/Downloads/comiket-lottery-app/backend/package.json`（まるごと置換）

```json
{
  "name": "lottery-backend",
  "version": "1.0.0",
  "main": "index.js",
  "type": "commonjs",
  "scripts": {
    "start": "node index.js"
  },
  "dependencies": {
    "body-parser": "^1.20.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "pg": "^8.12.0"
  }
}
```

## 2) `/Users/m-aoki/Downloads/comiket-lottery-app/backend/.env`（新規/置換：※Gitにコミットしない）
※ External URL を使う。最後に `?sslmode=require` を付けるのを推奨。

```
DATABASE_URL=postgresql://comiket_lottery_app_db_user:MAIa8lsYjxfkvoZjxTy63VJdGcjWFvUl@dpg-d2h9i2ur433s738316hg-a.oregon-postgres.render.com/comiket_lottery_app_db?sslmode=require
PORT=3001
# 公開前ガードを一時的に無効化したい場合のみ 1 を設定（本番は外す）
# FORCE_PUBLISH_ALL=1
```

## 3) `/Users/m-aoki/Downloads/comiket-lottery-app/backend/index.js`（まるごと置換）

```js
// Lottery backend (Postgres) - full replace
const express = require("express");
const cors = require("cors");
const bodyParser = require("body-parser");
const { Pool } = require("pg");
const path = require("path");
require("dotenv").config();

const app = express();
app.use(cors());
app.use(bodyParser.json());

const PORT = process.env.PORT || 3001;
const FORCE_PUBLISH_ALL = process.env.FORCE_PUBLISH_ALL === "1";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

// ---- helpers ----
function jstToUtcDate(jstStr) {
  if (!jstStr) return null; // "YYYY-MM-DD HH:MM"
  const [ymd, hm] = jstStr.split(" ");
  const [Y, M, D] = (ymd || "").split("-").map(Number);
  const [h, m] = (hm || "").split(":").map(Number);
  return new Date(Date.UTC(Y, (M || 1) - 1, D || 1, (h || 0) - 9, m || 0, 0));
}

async function getPrize(prizeId) {
  const { rows } = await pool.query(
    `select id, name, result_time_jst, publish_time_utc from prizes where id=$1`,
    [prizeId]
  );
  return rows[0] || null;
}
async function getEntry(prizeId, entryNumber) {
  const { rows } = await pool.query(
    `select id, prize_id, entry_number, password, is_winner
       from entries
      where prize_id=$1 and entry_number=$2`,
    [prizeId, entryNumber]
  );
  return rows[0] || null;
}
function isPublishedNow(prize) {
  if (FORCE_PUBLISH_ALL) return true;
  let publishUtc = prize.publish_time_utc ? new Date(prize.publish_time_utc) : null;
  if (!publishUtc && prize.result_time_jst) publishUtc = jstToUtcDate(prize.result_time_jst);
  if (!publishUtc || isNaN(publishUtc)) return true; // 未設定は公開扱い
  const now = new Date();
  return now >= publishUtc;
}

// ---- health ----
app.get("/api/now", (_req, res) => {
  res.json({ now_utc: new Date().toISOString() });
});

// ---- participant APIs ----
app.get("/api/product/:prizeId", async (req, res) => {
  try {
    const prize = await getPrize(req.params.prizeId);
    if (!prize) return res.status(404).json({ error: "not_found" });
    res.json({
      prizeId: prize.id,
      prizeName: prize.name,
      resultTimeJST: prize.result_time_jst || null,
      publishTimeParsedUTC:
        prize.publish_time_utc ||
        (prize.result_time_jst ? jstToUtcDate(prize.result_time_jst).toISOString() : null),
    });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "server_error" });
  }
});

app.post("/api/check", async (req, res) => {
  try {
    const { prizeId, entryNumber, password } = req.body || {};
    if (!prizeId || !entryNumber || !password) {
      return res.json({ result: "入力が不足しています。" });
    }
    const prize = await getPrize(prizeId);
    if (!prize) return res.json({ result: "該当の賞品が見つかりません。" });

    if (!isPublishedNow(prize)) {
      return res.json({ result: "まだ結果発表前です。公開時刻をお待ちください。" });
    }
    const entry = await getEntry(prizeId, entryNumber);
    if (!entry || entry.password !== password) {
      return res.json({ result: "抽選番号またはパスワードが正しくありません。" });
    }
    if (entry.is_winner) {
      return res.json({ result: `🎉 おめでとうございます！「${prize.name}」に当選しました！` });
    } else {
      return res.json({ result: `残念…「${prize.name}」は落選でした。` });
    }
  } catch (e) {
    console.error(e);
    res.status(500).json({ result: "サーバーエラーが発生しました。" });
  }
});

// ---- admin APIs (create/update/delete/list/bulk) ----
app.post("/api/admin/prize/upsert", async (req, res) => {
  try {
    const { id, name, resultTimeJST } = req.body || {};
    if (!id || !name) return res.status(400).json({ error: "missing_fields" });
    const publishUtc = resultTimeJST ? jstToUtcDate(resultTimeJST) : null;
    await pool.query(
      `insert into prizes (id, name, result_time_jst, publish_time_utc, updated_at)
       values ($1,$2,$3,$4, now())
       on conflict (id) do update
         set name=excluded.name,
             result_time_jst=excluded.result_time_jst,
             publish_time_utc=excluded.publish_time_utc,
             updated_at=now()`,
      [id, name, resultTimeJST || null, publishUtc ? publishUtc.toISOString() : null]
    );
    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "server_error" });
  }
});

app.post("/api/admin/prize/delete", async (req, res) => {
  try {
    const { id } = req.body || {};
    if (!id) return res.status(400).json({ error: "missing_id" });
    await pool.query(`delete from prizes where id=$1`, [id]); // cascade
    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "server_error" });
  }
});

app.post("/api/admin/entries/bulk", async (req, res) => {
  try {
    const { prizeId, entries } = req.body || {};
    if (!prizeId || !Array.isArray(entries)) return res.status(400).json({ error: "bad_request" });
    const client = await pool.connect();
    try {
      await client.query("begin");
      for (const e of entries) {
        await client.query(
          `insert into entries (prize_id, entry_number, password, is_winner)
           values ($1,$2,$3,$4)
           on conflict (prize_id, entry_number) do update
             set password=excluded.password, is_winner=excluded.is_winner`,
          [prizeId, e.entryNumber, e.password, !!e.isWinner]
        );
      }
      await client.query("commit");
    } catch (e) {
      await client.query("rollback");
      throw e;
    } finally {
      client.release();
    }
    res.json({ ok: true, count: entries.length });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "server_error" });
  }
});

app.post("/api/admin/entry/delete", async (req, res) => {
  try {
    const { prizeId, entryNumber } = req.body || {};
    if (!prizeId || !entryNumber) return res.status(400).json({ error: "missing_fields" });
    await pool.query(`delete from entries where prize_id=$1 and entry_number=$2`, [prizeId, entryNumber]);
    res.json({ ok: true });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "server_error" });
  }
});

app.get("/api/admin/entries/:prizeId", async (req, res) => {
  try {
    const { prizeId } = req.params;
    const { rows } = await pool.query(
      `select entry_number as "entryNumber", password, is_winner as "isWinner"
         from entries
        where prize_id=$1
        order by entry_number asc`,
      [prizeId]
    );
    res.json({ prizeId, entries: rows });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "server_error" });
  }
});

// (オプション) フロントのビルドを配信したい場合は下を有効化
/*
// const buildPath = path.join(__dirname, "..", "frontend", "build");
// app.use(express.static(buildPath));
// app.get("*", (_req, res) => res.sendFile(path.join(buildPath, "index.html")));
*/

app.listen(PORT, () => {
  console.log(`Lottery backend (DB) running on port ${PORT}`);
});
```

---

# ✅ フロント一式（管理GUI・参加者ページ・QR注釈PNG・CSVファイル対応・削除UI）

## 4) `/Users/m-aoki/Downloads/comiket-lottery-app/frontend/package.json`（まるごと置換）

```json
{
  "name": "lottery-frontend",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.7.7",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-qr-code": "^2.0.13",
    "react-router-dom": "^6.26.2",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "PORT=3000 react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  }
}
```

## 5) `/Users/m-aoki/Downloads/comiket-lottery-app/frontend/public/index.html`（まるごと置換）

```html
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>抽選アプリ</title>
  </head>
  <body>
    <noscript>このアプリを実行するには JavaScript を有効にしてください。</noscript>
    <div id="root"></div>
  </body>
</html>
```

## 6) `/Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/index.js`（まるごと置換）

```js
import React from "react";
import ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import App from "./App";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);
```

## 7) `/Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/App.jsx`（まるごと置換）

```jsx
import React from "react";
import { Routes, Route, Link } from "react-router-dom";
import Participant from "./Participant";
import Admin from "./Admin";

export default function App() {
  return (
    <div style={{ fontFamily: "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif" }}>
      <header style={{ padding: 12, borderBottom: "1px solid #e5e7eb", marginBottom: 12 }}>
        <div style={{ display: "flex", gap: 12, alignItems: "center" }}>
          <Link to="/" style={{ textDecoration: "none", color: "#111827", fontWeight: 700 }}>抽選アプリ</Link>
          <nav style={{ display: "flex", gap: 8 }}>
            <Link to="/" style={{ textDecoration: "none" }}>参加者ページ</Link>
            <Link to="/admin" style={{ textDecoration: "none" }}>管理画面</Link>
          </nav>
        </div>
      </header>

      <main style={{ padding: 16 }}>
        <Routes>
          <Route path="/" element={<Participant />} />
          <Route path="/admin" element={<Admin />} />
        </Routes>
      </main>
    </div>
  );
}
```

## 8) `/Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/Participant.jsx`（新規ファイル）

```jsx
import React, { useEffect, useMemo, useState } from "react";
import axios from "axios";

const API_BASE = process.env.REACT_APP_API_BASE || "http://localhost:3001";

export default function Participant() {
  const params = new URLSearchParams(window.location.search);
  const prizeId = params.get("prizeId") || "";

  const [info, setInfo] = useState(null);
  const [loading, setLoading] = useState(false);
  const [entryNumber, setEntryNumber] = useState("");
  const [password, setPassword] = useState("");
  const [result, setResult] = useState("");

  const isReady = useMemo(() => !!prizeId, [prizeId]);

  useEffect(() => {
    if (!isReady) return;
    (async () => {
      setLoading(true);
      try {
        const r = await axios.get(`${API_BASE}/api/product/${encodeURIComponent(prizeId)}`);
        setInfo(r.data);
      } catch {
        setInfo(null);
      } finally {
        setLoading(false);
      }
    })();
  }, [isReady, prizeId]);

  const submit = async (e) => {
    e.preventDefault();
    setResult("");
    try {
      const r = await axios.post(`${API_BASE}/api/check`, {
        prizeId,
        entryNumber,
        password
      });
      setResult(r.data.result || "");
    } catch {
      setResult("通信エラーが発生しました。");
    }
  };

  return (
    <div style={{ maxWidth: 560 }}>
      <h1>参加者ページ</h1>
      {!prizeId && <div style={{ color: "crimson" }}>URLに <code>?prizeId=...</code> を付けてアクセスしてください。</div>}
      {loading && <div>読み込み中...</div>}
      {info && (
        <div style={{ background: "#f9fafb", border: "1px solid #e5e7eb", borderRadius: 12, padding: 12, marginBottom: 12 }}>
          <div><b>賞品ID:</b> {info.prizeId}</div>
          <div><b>賞品名:</b> {info.prizeName}</div>
          <div><b>公開時刻(JST):</b> {info.resultTimeJST || "未設定（すぐ確認できます）"}</div>
        </div>
      )}

      <form onSubmit={submit} style={{ display: "grid", gap: 8 }}>
        <label>抽選番号</label>
        <input value={entryNumber} onChange={(e) => setEntryNumber(e.target.value)} required
               style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }}/>
        <label>パスワード</label>
        <input value={password} onChange={(e) => setPassword(e.target.value)} required type="password"
               style={{ padding: 10, borderRadius: 8, border: "1px solid #d1d5db" }}/>
        <button type="submit" style={{ padding: "10px 14px", borderRadius: 8, border: "1px solid #2563eb", background: "#2563eb", color: "white", fontWeight: 600, cursor: "pointer" }}>
          結果を確認
        </button>
      </form>

      {result && (
        <div style={{ marginTop: 12, background: "#eef2ff", border: "1px solid #c7d2fe", padding: 12, borderRadius: 8 }}>
          {result}
        </div>
      )}
    </div>
  );
}
```

## 9) `/Users/m-aoki/Downloads/comiket-lottery-app/frontend/src/Admin.jsx`（まるごと置換）
※ ご要望の「削除GUI」「CSVファイル対応」「注釈入りQR PNG保存」「日本語UI」を含みます。

```jsx
// full Admin GUI with delete & CSV & annotated QR
import React, { useMemo, useRef, useState } from "react";
import axios from "axios";
import QRCode from "react-qr-code";

const API_BASE = process.env.REACT_APP_API_BASE || "http://localhost:3001";
const FRONT_BASE = process.env.REACT_APP_FRONT_BASE || "http://localhost:3000";

function Section({ title, subtitle, children }) {
  return (
    <section style={{ border: "1px solid #e5e7eb", borderRadius: 12, padding: 16, marginBottom: 16 }}>
      <h2 style={{ margin: "0 0 6px 0", fontSize: 18 }}>{title}</h2>
      {subtitle && <div style={{ color: "#6b7280", fontSize: 13, marginBottom: 10 }}>{subtitle}</div>}
      {children}
    </section>
  );
}

export default function Admin() {
  const [activeTab, setActiveTab] = useState("qr"); // 'qr' | 'prize' | 'entries'

  // ===== ① QR配布 =====
  const [idsInput, setIdsInput] = useState("A001");
  const prizeIds = useMemo(
    () => idsInput.split(",").map((s) => s.trim()).filter(Boolean),
    [idsInput]
  );
  const [qrItems, setQrItems] = useState([]);
  const [qrLoading, setQrLoading] = useState(false);

  const buildUrl = (id) => `${FRONT_BASE}/?prizeId=${encodeURIComponent(id)}`;

  const loadInfoForQR = async () => {
    setQrLoading(true);
    const result = [];
    for (const id of prizeIds) {
      try {
        const res = await axios.get(`${API_BASE}/api/product/${encodeURIComponent(id)}`);
        result.push({ id, ok: true, data: res.data });
      } catch {
        result.push({ id, ok: false, error: "取得失敗" });
      }
    }
    setQrItems(result);
    setQrLoading(false);
  };

  const copyUrl = async (url) => {
    try {
      await navigator.clipboard.writeText(url);
      alert("URLをコピーしました");
    } catch {
      alert("コピーに失敗しました");
    }
  };

  // 注釈入りPNG保存
  const downloadPngAnnotated = (item) => {
    const { id, data } = item;
    const svg = document.getElementById(`qr-${id}`);
    if (!svg) return;
    const xml = new XMLSerializer().serializeToString(svg);
    const svg64 = window.btoa(unescape(encodeURIComponent(xml)));
    const img = new Image();
    img.onload = () => {
      const QR_SIZE = 660;
      const W = 660;
      const PAD = 24;
      const TEXT_H = 18;
      const LINES = [
        `ID: ${id}`,
        `公開予定(JST): ${data?.resultTimeJST || "未設定"}`,
        `URL: ${buildUrl(id)}`
      ];
      const INFO_H = PAD + LINES.length * (TEXT_H + 6) + PAD;
      const H = QR_SIZE + INFO_H;
      const canvas = document.createElement("canvas");
      canvas.width = W;
      canvas.height = H;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, W, H);
      ctx.drawImage(img, (W - QR_SIZE) / 2, PAD, QR_SIZE, QR_SIZE);
      ctx.strokeStyle = "#e5e7eb";
      ctx.strokeRect(0.5, 0.5, W - 1, H - 1);
      ctx.fillStyle = "#111827";
      ctx.font = "16px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif";
      let y = QR_SIZE + PAD + 18;
      for (const line of LINES) {
        const maxWidth = W - PAD * 2;
        const words = line.split(" ");
        let tmp = "";
        for (const w of words) {
          const test = tmp ? tmp + " " + w : w;
          if (ctx.measureText(test).width > maxWidth) {
            ctx.fillText(tmp, PAD, y);
            y += TEXT_H + 6;
            tmp = w;
          } else {
            tmp = test;
          }
        }
        if (tmp) {
          ctx.fillText(tmp, PAD, y);
          y += TEXT_H + 6;
        }
      }
      const link = document.createElement("a");
      link.download = `qr-${id}.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    };
    img.src = "data:image/svg+xml;base64," + svg64;
  };

  // ===== ② 賞品の登録・編集（削除あり） =====
  const [pzId, setPzId] = useState("A001");
  const [pzName, setPzName] = useState("");
  const [pzResultJST, setPzResultJST] = useState(""); // "YYYY-MM-DD HH:MM"
  const [pzMsg, setPzMsg] = useState("");

  const fetchPrize = async () => {
    setPzMsg("");
    if (!pzId) return setPzMsg("賞品IDを入力してください。");
    try {
      const r = await axios.get(`${API_BASE}/api/product/${encodeURIComponent(pzId)}`);
      setPzName(r.data.prizeName || "");
      setPzResultJST(r.data.resultTimeJST || "");
      setPzMsg("読み込み成功。内容を編集して「保存する」を押してください。");
    } catch {
      setPzMsg("読み込みに失敗しました。新規作成する場合は名前と公開時刻を入力して「保存する」を押してください。");
      setPzName("");
      setPzResultJST("");
    }
  };

  const savePrize = async () => {
    setPzMsg("");
    if (!pzId || !pzName) return setPzMsg("賞品IDと名前は必須です。");
    if (pzResultJST && !/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}$/.test(pzResultJST)) {
      return setPzMsg("公開時刻（JST）は 例）2025-08-20 12:00 の形式で入力してください。");
    }
    try {
      await axios.post(`${API_BASE}/api/admin/prize/upsert`, {
        id: pzId,
        name: pzName,
        resultTimeJST: pzResultJST || null,
      });
      setPzMsg("保存しました。");
    } catch {
      setPzMsg("保存に失敗しました。");
    }
  };

  const deletePrize = async () => {
    if (!pzId) return setPzMsg("賞品IDを入力してください。");
    if (!window.confirm(`賞品「${pzId}」を削除します。関連する参加者データも削除されます。よろしいですか？`)) return;
    try {
      await axios.post(`${API_BASE}/api/admin/prize/delete`, { id: pzId });
      setPzName("");
      setPzResultJST("");
      setPzMsg("削除しました。");
    } catch {
      setPzMsg("削除に失敗しました。");
    }
  };

  // ===== ③ 参加者リスト登録（CSV）／一覧・削除 =====
  const [enPrizeId, setEnPrizeId] = useState("A001");
  const [csvText, setCsvText] = useState("entryNumber,password,isWinner\n001,1234,true\n002,5678,false");
  const [entriesPreview, setEntriesPreview] = useState([]);
  const [enMsg, setEnMsg] = useState("");
  const fileRef = useRef(null);
  const [remoteEntries, setRemoteEntries] = useState([]);

  const parseCSVText = (text) => {
    const lines = text.split(/\r?\n/).map((l) => l.trim()).filter(Boolean);
    if (lines.length === 0) return [];
    let start = 0;
    if (/entrynumber/i.test(lines[0]) && /password/i.test(lines[0])) start = 1;
    const out = [];
    for (let i = start; i < lines.length; i++) {
      const cols = lines[i].split(",").map((c) => c.trim());
      if (cols.length < 2) continue;
      const entryNumber = cols[0];
      const password = cols[1];
      const isWinner = (cols[2] || "").toLowerCase() === "true";
      if (!entryNumber || !password) continue;
      out.push({ entryNumber, password, isWinner });
    }
    return out;
  };

  const parseCSV = () => {
    setEnMsg("");
    const out = parseCSVText(csvText);
    setEntriesPreview(out);
    if (out.length === 0) setEnMsg("有効な行が見つかりませんでした。");
  };

  const onSelectCSV = async (e) => {
    setEnMsg("");
    const f = e.target.files?.[0];
    if (!f) return;
    const text = await f.text();
    setCsvText(text);
    const out = parseCSVText(text);
    setEntriesPreview(out);
    if (out.length === 0) setEnMsg("有効な行が見つかりませんでした。");
  };

  const uploadEntries = async () => {
    setEnMsg("");
    if (!enPrizeId) return setEnMsg("賞品IDを入力してください。");
    if (entriesPreview.length === 0) return setEnMsg("先にCSVを解析してください。");
    try {
      const r = await axios.post(`${API_BASE}/api/admin/entries/bulk`, {
        prizeId: enPrizeId,
        entries: entriesPreview,
      });
      setEnMsg(`登録に成功しました：${r.data.count} 件`);
      await fetchRemoteEntries();
    } catch {
      setEnMsg("登録に失敗しました。");
    }
  };

  const fetchRemoteEntries = async () => {
    setEnMsg("");
